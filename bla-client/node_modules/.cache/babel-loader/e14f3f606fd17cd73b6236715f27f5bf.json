{"ast":null,"code":"import React, { createContext, useContext, useRef, useReducer, useState, useEffect, useLayoutEffect } from 'react';\nimport _objectSpread from '@babel/runtime/helpers/objectSpread2';\nimport { compose, createStore as createStore$1, applyMiddleware } from 'redux';\nimport reduxThunk from 'redux-thunk';\nimport { isDraft, current, Immer, original } from 'immer';\nvar StoreContext = createContext(); // To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser. We need useLayoutEffect to ensure the store\n// subscription callback always has the selector from the latest render commit\n// available, otherwise a store update may happen between render and the effect,\n// which may cause missed updates; we also must ensure the store subscription\n// is created synchronously, otherwise a store update may occur before the\n// subscription is created and an inconsistent state may be observed\n\nvar useIsomorphicLayoutEffect = typeof window !== 'undefined' ? useLayoutEffect : useEffect;\n\nfunction createStoreStateHook(Context) {\n  return function useStoreState(mapState, equalityFn) {\n    var store = useContext(Context);\n    var mapStateRef = useRef(mapState);\n    var stateRef = useRef();\n    var mountedRef = useRef(true);\n    var subscriptionMapStateError = useRef();\n\n    var _useReducer = useReducer(function (s) {\n      return s + 1;\n    }, 0),\n        forceRender = _useReducer[1];\n\n    if (subscriptionMapStateError.current || mapStateRef.current !== mapState || stateRef.current === undefined) {\n      try {\n        stateRef.current = mapState(store.getState());\n      } catch (err) {\n        if (process.env.NODE_ENV === 'development') {\n          var errorMessage = \"Error in useStoreState: \" + err.message + \".\";\n\n          if (subscriptionMapStateError.current) {\n            errorMessage += \"\\nMaybe related to:\\n\" + subscriptionMapStateError.current.stack;\n          }\n\n          throw new Error(errorMessage);\n        }\n\n        throw subscriptionMapStateError.current || err;\n      }\n    }\n\n    useIsomorphicLayoutEffect(function () {\n      mapStateRef.current = mapState;\n      subscriptionMapStateError.current = undefined;\n    });\n    useIsomorphicLayoutEffect(function () {\n      var checkMapState = function checkMapState() {\n        try {\n          var newState = mapStateRef.current(store.getState());\n          var isStateEqual = typeof equalityFn === 'function' ? equalityFn(stateRef.current, newState) : stateRef.current === newState;\n\n          if (isStateEqual) {\n            return;\n          }\n\n          stateRef.current = newState;\n        } catch (err) {\n          // see https://github.com/reduxjs/react-redux/issues/1179\n          // There is a possibility mapState will fail due to stale state or\n          // props, therefore we will just track the error and force our\n          // component to update. It should then receive the updated state\n          subscriptionMapStateError.current = err;\n        }\n\n        if (mountedRef.current) {\n          forceRender({});\n        }\n      };\n\n      var unsubscribe = store.subscribe(checkMapState);\n      checkMapState();\n      return function () {\n        mountedRef.current = false;\n        unsubscribe();\n      };\n    }, []);\n    return stateRef.current;\n  };\n}\n\nvar useStoreState = createStoreStateHook(StoreContext);\n\nfunction createStoreActionsHook(Context) {\n  return function useStoreActions(mapActions) {\n    var store = useContext(Context);\n    return mapActions(store.getActions());\n  };\n}\n\nvar useStoreActions = createStoreActionsHook(StoreContext);\n\nfunction createStoreDispatchHook(Context) {\n  return function useStoreDispatch() {\n    var store = useContext(Context);\n    return store.dispatch;\n  };\n}\n\nvar useStoreDispatch = createStoreDispatchHook(StoreContext);\n\nfunction useStore() {\n  return useContext(StoreContext);\n}\n\nfunction createStoreRehydratedHook(Context) {\n  return function useStoreRehydrated() {\n    var store = useContext(Context);\n\n    var _useState = useState(false),\n        rehydrated = _useState[0],\n        setRehydrated = _useState[1];\n\n    useEffect(function () {\n      store.persist.resolveRehydration().then(function () {\n        return setRehydrated(true);\n      });\n    }, []);\n    return rehydrated;\n  };\n}\n\nvar useStoreRehydrated = createStoreRehydratedHook(StoreContext);\n\nfunction createTypedHooks() {\n  return {\n    useStoreActions: useStoreActions,\n    useStoreDispatch: useStoreDispatch,\n    useStoreState: useStoreState,\n    useStoreRehydrated: useStoreRehydrated,\n    useStore: useStore\n  };\n}\n\nvar actionSymbol = '$_a';\nvar actionOnSymbol = '$_aO';\nvar computedSymbol = '$_c';\nvar effectOnSymbol = '$_e';\nvar persistSymbol = '$_p';\nvar reducerSymbol = '$_r';\nvar thunkOnSymbol = '$_tO';\nvar thunkSymbol = '$_t';\n\nvar debug = function debug(state) {\n  if (isDraft(state)) {\n    return current(state);\n  }\n\n  return state;\n};\n\nvar actionOn = function actionOn(targetResolver, fn) {\n  var _ref;\n\n  return _ref = {}, _ref[actionOnSymbol] = true, _ref.fn = fn, _ref.targetResolver = targetResolver, _ref;\n};\n\nvar action = function action(fn) {\n  var _ref2;\n\n  return _ref2 = {}, _ref2[actionSymbol] = true, _ref2.fn = fn, _ref2;\n};\n\nvar defaultStateResolvers = [function (state) {\n  return state;\n}];\n\nvar computed = function computed(fnOrStateResolvers, fn) {\n  var _ref4;\n\n  if (typeof fn === 'function') {\n    var _ref3;\n\n    return _ref3 = {}, _ref3[computedSymbol] = true, _ref3.fn = fn, _ref3.stateResolvers = fnOrStateResolvers, _ref3;\n  }\n\n  return _ref4 = {}, _ref4[computedSymbol] = true, _ref4.fn = fnOrStateResolvers, _ref4.stateResolvers = defaultStateResolvers, _ref4;\n};\n\nfunction unstable_effectOn(dependencyResolvers, fn) {\n  var _ref5;\n\n  return _ref5 = {}, _ref5[effectOnSymbol] = true, _ref5.dependencyResolvers = dependencyResolvers, _ref5.fn = fn, _ref5;\n}\n\nfunction generic(value) {\n  return value;\n}\n\nvar persist = function persist(model, config) {\n  var _objectSpread2;\n\n  return (// if we are not running in a browser context this becomes a no-op\n    typeof window === 'undefined' ? model : _objectSpread(_objectSpread({}, model), {}, (_objectSpread2 = {}, _objectSpread2[persistSymbol] = config, _objectSpread2))\n  );\n};\n\nvar thunkOn = function thunkOn(targetResolver, fn) {\n  var _ref6;\n\n  return _ref6 = {}, _ref6[thunkOnSymbol] = true, _ref6.fn = fn, _ref6.targetResolver = targetResolver, _ref6;\n};\n\nvar thunk = function thunk(fn) {\n  var _ref7;\n\n  return _ref7 = {}, _ref7[thunkSymbol] = true, _ref7.fn = fn, _ref7;\n};\n\nvar reducer = function reducer(fn) {\n  var _ref8;\n\n  return _ref8 = {}, _ref8[reducerSymbol] = true, _ref8.fn = fn, _ref8;\n};\n/**\n * We create our own immer instance to avoid potential issues with autoFreeze\n * becoming default enabled everywhere. We want to disable autofreeze as it\n * does not suit the design of Easy Peasy.\n * https://github.com/immerjs/immer/issues/681#issuecomment-705581111\n */\n\n\nvar easyPeasyImmer;\n\nfunction isPlainObject(obj) {\n  if (typeof obj !== 'object' || obj === null) return false;\n  var proto = obj;\n\n  while (Object.getPrototypeOf(proto) !== null) {\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return Object.getPrototypeOf(obj) === proto;\n}\n\nfunction clone(source) {\n  function recursiveClone(current) {\n    var next = Object.keys(current).reduce(function (acc, key) {\n      if (Object.getOwnPropertyDescriptor(current, key).get == null) {\n        acc[key] = current[key];\n      }\n\n      return acc;\n    }, {});\n    Object.keys(next).forEach(function (key) {\n      if (isPlainObject(next[key])) {\n        next[key] = recursiveClone(next[key]);\n      }\n    });\n    return next;\n  }\n\n  return recursiveClone(source);\n}\n\nfunction isPromise(x) {\n  return x != null && typeof x === 'object' && typeof x.then === 'function';\n}\n\nfunction get(path, target) {\n  return path.reduce(function (acc, cur) {\n    return isPlainObject(acc) ? acc[cur] : undefined;\n  }, target);\n}\n\nfunction newify(currentPath, currentState, finalValue) {\n  if (currentPath.length === 0) {\n    return finalValue;\n  }\n\n  var newState = _objectSpread({}, currentState);\n\n  var key = currentPath[0];\n\n  if (currentPath.length === 1) {\n    newState[key] = finalValue;\n  } else {\n    newState[key] = newify(currentPath.slice(1), newState[key], finalValue);\n  }\n\n  return newState;\n}\n\nfunction set(path, target, value) {\n  if (path.length === 0) {\n    if (typeof value === 'object') {\n      Object.keys(target).forEach(function (key) {\n        delete target[key];\n      });\n      Object.keys(value).forEach(function (key) {\n        target[key] = value[key];\n      });\n    }\n\n    return;\n  }\n\n  path.reduce(function (acc, cur, idx) {\n    if (idx + 1 === path.length) {\n      acc[cur] = value;\n    } else {\n      acc[cur] = acc[cur] || {};\n    }\n\n    return acc[cur];\n  }, target);\n}\n\nfunction createSimpleProduce(disableImmer) {\n  if (disableImmer === void 0) {\n    disableImmer = false;\n  }\n\n  return function simpleProduce(path, state, fn) {\n    if (disableImmer) {\n      var _current = get(path, state);\n\n      var next = fn(_current);\n\n      if (_current !== next) {\n        return newify(path, state, next);\n      }\n\n      return state;\n    }\n\n    if (!easyPeasyImmer) {\n      easyPeasyImmer = new Immer({\n        // We need to ensure that we disable proxies if they aren't available\n        // on the environment. Users need to ensure that they use the enableES5\n        // feature of immer.\n        useProxies: typeof Proxy !== 'undefined' && typeof Proxy.revocable !== 'undefined' && typeof Reflect !== 'undefined',\n        // Autofreezing breaks easy-peasy, we need a mixed version of immutability\n        // and mutability in order to apply updates to our computed properties\n        autoFreeze: false\n      });\n    }\n\n    if (path.length === 0) {\n      var _draft = easyPeasyImmer.createDraft(state);\n\n      var _result = fn(_draft);\n\n      if (_result) {\n        return isDraft(_result) ? easyPeasyImmer.finishDraft(_result) : _result;\n      }\n\n      return easyPeasyImmer.finishDraft(_draft);\n    }\n\n    var parentPath = path.slice(0, path.length - 1);\n    var draft = easyPeasyImmer.createDraft(state);\n    var parent = get(parentPath, state);\n    var current = get(path, draft);\n    var result = fn(current);\n\n    if (result) {\n      parent[path[path.length - 1]] = result;\n    }\n\n    return easyPeasyImmer.finishDraft(draft);\n  };\n}\n\nvar pReduce = function pReduce(iterable, reducer, initialValue) {\n  return new Promise(function (resolve, reject) {\n    var iterator = iterable[Symbol.iterator]();\n    var index = 0;\n\n    var next = function next(total) {\n      var element = iterator.next();\n\n      if (element.done) {\n        resolve(total);\n        return;\n      }\n\n      Promise.all([total, element.value]).then(function (value) {\n        return (// eslint-disable-next-line no-plusplus\n          next(reducer(value[0], value[1], index++))\n        );\n      }).catch(function (err) {\n        return reject(err);\n      });\n    };\n\n    next(initialValue);\n  });\n};\n\nvar pSeries = function pSeries(tasks) {\n  var results = [];\n  return pReduce(tasks, function (_, task) {\n    return task().then(function (value) {\n      results.push(value);\n    });\n  }).then(function () {\n    return results;\n  });\n};\n\nfunction areInputsEqual(newInputs, lastInputs) {\n  if (newInputs.length !== lastInputs.length) {\n    return false;\n  }\n\n  for (var i = 0; i < newInputs.length; i += 1) {\n    if (newInputs[i] !== lastInputs[i]) {\n      return false;\n    }\n  }\n\n  return true;\n} // export function memoizeOne(resultFn) {\n//   let lastArgs = [];\n//   let lastResult;\n//   let calledOnce = false;\n//   return function memoized(...args) {\n//     if (calledOnce && areInputsEqual(args, lastArgs)) {\n//       return lastResult;\n//     }\n//     lastResult = resultFn(...args);\n//     calledOnce = true;\n//     lastArgs = args;\n//     return lastResult;\n//   };\n// }\n\n\nfunction useMemoOne( // getResult changes on every call,\ngetResult, // the inputs array changes on every call\ninputs) {\n  // using useState to generate initial value as it is lazy\n  var initial = React.useState(function () {\n    return {\n      inputs: inputs,\n      result: getResult()\n    };\n  })[0];\n  var committed = React.useRef(initial); // persist any uncommitted changes after they have been committed\n\n  var isInputMatch = Boolean(inputs && committed.current.inputs && areInputsEqual(inputs, committed.current.inputs)); // create a new cache if required\n\n  var cache = isInputMatch ? committed.current : {\n    inputs: inputs,\n    result: getResult()\n  }; // commit the cache\n\n  React.useEffect(function () {\n    committed.current = cache;\n  }, [cache]);\n  return cache.result;\n}\n\nfunction createReducer(disableImmer, _aRD, _cR, _cP) {\n  var simpleProduce = createSimpleProduce(disableImmer);\n\n  var runActionReducerAtPath = function runActionReducerAtPath(state, action, actionReducer, path) {\n    return simpleProduce(path, state, function (draft) {\n      return actionReducer(draft, action.payload);\n    });\n  };\n\n  var reducerForActions = function reducerForActions(state, action) {\n    var actionReducer = _aRD[action.type];\n\n    if (actionReducer) {\n      return runActionReducerAtPath(state, action, actionReducer, actionReducer.def.meta.parent);\n    }\n\n    return state;\n  };\n\n  var reducerForCustomReducers = function reducerForCustomReducers(state, action) {\n    return _cR.reduce(function (acc, _ref) {\n      var parentPath = _ref.parentPath,\n          key = _ref.key,\n          reducer = _ref.reducer;\n      return simpleProduce(parentPath, acc, function (draft) {\n        draft[key] = reducer(isDraft(draft[key]) ? original(draft[key]) : draft[key], action);\n        return draft;\n      });\n    }, state);\n  };\n\n  var rootReducer = function rootReducer(state, action) {\n    var stateAfterActions = reducerForActions(state, action);\n    var next = _cR.length > 0 ? reducerForCustomReducers(stateAfterActions, action) : stateAfterActions;\n\n    if (state !== next) {\n      _cP.forEach(function (_ref2) {\n        var parentPath = _ref2.parentPath,\n            bindComputedProperty = _ref2.bindComputedProperty;\n        var parentState = get(parentPath, next);\n        if (parentState != null) bindComputedProperty(parentState, next);\n      });\n    }\n\n    return next;\n  };\n\n  return rootReducer;\n}\n\nvar noopStorage = {\n  getItem: function getItem() {\n    return undefined;\n  },\n  setItem: function setItem() {\n    return undefined;\n  },\n  removeItem: function removeItem() {\n    return undefined;\n  }\n};\n\nvar getBrowerStorage = function getBrowerStorage(storageName) {\n  var storageCache;\n  return function () {\n    if (!storageCache) {\n      try {\n        if (typeof window !== 'undefined' && typeof window[storageName] !== 'undefined') {\n          storageCache = window[storageName];\n        }\n      } catch (_) {// swallow the failure\n      }\n\n      if (!storageCache) {\n        storageCache = noopStorage;\n      }\n    }\n\n    return storageCache;\n  };\n};\n\nvar localStorage = getBrowerStorage('localStorage');\nvar sessionStorage = getBrowerStorage('sessionStorage');\n\nfunction createStorageWrapper(storage, transformers) {\n  if (transformers === void 0) {\n    transformers = [];\n  }\n\n  if (storage == null) {\n    storage = sessionStorage();\n  }\n\n  if (typeof storage === 'string') {\n    if (storage === 'localStorage') {\n      storage = localStorage();\n    } else if (storage === 'sessionStorage') {\n      storage = sessionStorage();\n    } else {\n      if (process.env.NODE_ENV === 'development') {\n        console.warn(\"Invalid storage provider\");\n      }\n\n      storage = noopStorage;\n    }\n  }\n\n  var outTransformers = [].concat(transformers).reverse();\n\n  var serialize = function serialize(data) {\n    if (transformers.length > 0 && data != null && typeof data === 'object') {\n      Object.keys(data).forEach(function (key) {\n        data[key] = transformers.reduce(function (acc, cur) {\n          return cur.in(acc, key);\n        }, data[key]);\n      });\n    }\n\n    return storage === localStorage() || storage === sessionStorage() ? JSON.stringify({\n      data: data\n    }) : data;\n  };\n\n  var deserialize = function deserialize(data) {\n    var result = storage === localStorage() || storage === sessionStorage() ? JSON.parse(data).data : data;\n\n    if (outTransformers.length > 0 && result != null && typeof result === 'object') {\n      Object.keys(result).forEach(function (key) {\n        result[key] = outTransformers.reduce(function (acc, cur) {\n          return cur.out(acc, key);\n        }, result[key]);\n      });\n    }\n\n    return result;\n  };\n\n  var isAsync = isPromise(storage.getItem('_'));\n  return {\n    getItem: function getItem(key) {\n      if (isAsync) {\n        return storage.getItem(key).then(function (wrapped) {\n          return wrapped != null ? deserialize(wrapped) : undefined;\n        });\n      }\n\n      var wrapped = storage.getItem(key);\n      return wrapped != null ? deserialize(wrapped) : undefined;\n    },\n    setItem: function setItem(key, data) {\n      return storage.setItem(key, serialize(data));\n    },\n    removeItem: function removeItem(key) {\n      return storage.removeItem(key);\n    }\n  };\n}\n\nfunction extractPersistConfig(path, persistdef) {\n  if (persistdef === void 0) {\n    persistdef = {};\n  }\n\n  return {\n    path: path,\n    config: {\n      allow: persistdef.allow || [],\n      deny: persistdef.deny || [],\n      mergeStrategy: persistdef.mergeStrategy || 'mergeDeep',\n      storage: createStorageWrapper(persistdef.storage, persistdef.transformers)\n    }\n  };\n}\n\nfunction resolvePersistTargets(target, allow, deny) {\n  var targets = Object.keys(target);\n\n  if (allow.length > 0) {\n    targets = targets.reduce(function (acc, cur) {\n      if (allow.findIndex(function (x) {\n        return x === cur;\n      }) !== -1) {\n        return [].concat(acc, [cur]);\n      }\n\n      return acc;\n    }, []);\n  }\n\n  if (deny.length > 0) {\n    targets = targets.reduce(function (acc, cur) {\n      if (deny.findIndex(function (x) {\n        return x === cur;\n      }) !== -1) {\n        return acc;\n      }\n\n      return [].concat(acc, [cur]);\n    }, []);\n  }\n\n  return targets;\n}\n\nfunction createPersistenceClearer(persistKey, _r) {\n  return function () {\n    if (_r._i._persistenceConfig.length === 0) {\n      return Promise.resolve();\n    }\n\n    return pSeries(_r._i._persistenceConfig.map(function (_ref) {\n      var path = _ref.path,\n          config = _ref.config;\n      return function () {\n        return Promise.resolve(config.storage.removeItem(persistKey(path)));\n      };\n    }));\n  };\n}\n\nfunction createPersistor(persistKey, _r) {\n  var persistPromise = Promise.resolve();\n  var isPersisting = false;\n  var nextPersistOperation;\n  var timingMethod = typeof window === 'undefined' ? function (fn) {\n    return fn();\n  } : window.requestIdleCallback != null ? window.requestIdleCallback : window.requestAnimationFrame;\n\n  var persist = function persist(nextState) {\n    if (_r._i._persistenceConfig.length === 0) {\n      return;\n    }\n\n    var operation = function operation() {\n      isPersisting = true;\n      persistPromise = new Promise(function (resolve) {\n        timingMethod(function () {\n          pSeries(_r._i._persistenceConfig.map(function (_ref2) {\n            var path = _ref2.path,\n                config = _ref2.config;\n            return function () {\n              var storage = config.storage,\n                  allow = config.allow,\n                  deny = config.deny;\n              var persistRootState = clone(get(path, nextState));\n              var persistTargets = resolvePersistTargets(persistRootState, allow, deny);\n              var stateToPersist = {};\n              persistTargets.map(function (key) {\n                var targetPath = [].concat(path, [key]);\n                var rawValue = get(targetPath, nextState);\n                var value = isPlainObject(rawValue) ? clone(rawValue) : rawValue;\n                stateToPersist[key] = value;\n              });\n              return Promise.resolve(storage.setItem(persistKey(path), stateToPersist));\n            };\n          })).finally(function () {\n            isPersisting = false;\n\n            if (nextPersistOperation) {\n              var next = nextPersistOperation;\n              nextPersistOperation = null;\n              next();\n            } else {\n              resolve();\n            }\n          });\n        });\n      });\n    };\n\n    if (isPersisting) {\n      nextPersistOperation = operation;\n    } else {\n      operation();\n    }\n  };\n\n  return {\n    persist: persist,\n    clear: createPersistenceClearer(persistKey, _r),\n    flush: function flush() {\n      if (nextPersistOperation) {\n        nextPersistOperation();\n      }\n\n      return persistPromise;\n    }\n  };\n}\n\nfunction createPersistMiddleware(persistor, _r) {\n  return function (_ref3) {\n    var getState = _ref3.getState;\n    return function (next) {\n      return function (action) {\n        var state = next(action);\n\n        if (action && action.type !== '@action.ePRS' && _r._i._persistenceConfig.length > 0) {\n          persistor.persist(getState());\n        }\n\n        return state;\n      };\n    };\n  };\n}\n\nfunction rehydrateStateFromPersistIfNeeded(persistKey, replaceState, _r, root) {\n  if (_r._i._persistenceConfig.length === 0) {\n    return Promise.resolve();\n  }\n\n  var state = clone(_r._i._dS);\n  var rehydrating = false;\n  return pSeries(_r._i._persistenceConfig.map(function (persistInstance) {\n    return function () {\n      var path = persistInstance.path,\n          config = persistInstance.config;\n      var mergeStrategy = config.mergeStrategy,\n          storage = config.storage;\n\n      if (root && (path.length < 1 || path[0] !== root)) {\n        return Promise.resolve();\n      }\n\n      var hasDataModelChanged = function hasDataModelChanged(dataModel, rehydratingModelData) {\n        return dataModel != null && rehydratingModelData != null && (typeof dataModel !== typeof rehydratingModelData || Array.isArray(dataModel) && !Array.isArray(rehydratingModelData));\n      };\n\n      var applyRehydrationStrategy = function applyRehydrationStrategy(persistedState) {\n        if (mergeStrategy === 'overwrite') {\n          set(path, state, persistedState);\n        } else if (mergeStrategy === 'mergeShallow') {\n          var targetState = get(path, state);\n          Object.keys(persistedState).forEach(function (key) {\n            if (hasDataModelChanged(targetState[key], persistedState[key])) ;else {\n              targetState[key] = persistedState[key];\n            }\n          });\n        } else if (mergeStrategy === 'mergeDeep') {\n          var _targetState = get(path, state);\n\n          var setAt = function setAt(currentTargetState, currentPersistedState) {\n            Object.keys(currentPersistedState).forEach(function (key) {\n              if (hasDataModelChanged(currentTargetState[key], currentPersistedState[key])) ;else if (isPlainObject(currentPersistedState[key])) {\n                currentTargetState[key] = currentTargetState[key] || {};\n                setAt(currentTargetState[key], currentPersistedState[key]);\n              } else {\n                currentTargetState[key] = currentPersistedState[key];\n              }\n            });\n          };\n\n          setAt(_targetState, persistedState);\n        }\n      };\n\n      var rehydate = function rehydate(persistedState) {\n        if (persistedState != null) {\n          applyRehydrationStrategy(persistedState);\n          rehydrating = true;\n        }\n      };\n\n      var getItemResult = storage.getItem(persistKey(path));\n\n      if (isPromise(getItemResult)) {\n        return getItemResult.then(rehydate);\n      }\n\n      return Promise.resolve(rehydate(getItemResult));\n    };\n  })).then(function () {\n    if (rehydrating) {\n      replaceState(state);\n    }\n  });\n}\n\nfunction createActionCreator(def, _r) {\n  function actionCreator(payload) {\n    var action = {\n      type: def.meta.type,\n      payload: payload\n    };\n\n    if (def[actionOnSymbol] && def.meta.resolvedTargets) {\n      payload.resolvedTargets = [].concat(def.meta.resolvedTargets);\n    }\n\n    return _r.dispatch(action);\n  } // We bind the types to the creator for easy reference by consumers\n\n\n  actionCreator.type = def.meta.type;\n  return actionCreator;\n}\n\nfunction createThunkHandler(def, _r, injections, _aC) {\n  return function (payload, fail) {\n    var helpers = {\n      dispatch: _r.dispatch,\n      fail: fail,\n      getState: function getState() {\n        return get(def.meta.parent, _r.getState());\n      },\n      getStoreActions: function getStoreActions() {\n        return _aC;\n      },\n      getStoreState: _r.getState,\n      injections: injections,\n      meta: {\n        key: def.meta.actionName,\n        parent: def.meta.parent,\n        path: def.meta.path\n      }\n    };\n\n    if (def[thunkOnSymbol] && def.meta.resolvedTargets) {\n      payload.resolvedTargets = [].concat(def.meta.resolvedTargets);\n    }\n\n    return def.fn(get(def.meta.parent, _aC), payload, helpers);\n  };\n}\n\nvar logThunkEventListenerError = function logThunkEventListenerError(type, err) {\n  // eslint-disable-next-line no-console\n  console.log(\"Error in \" + type); // eslint-disable-next-line no-console\n\n  console.log(err);\n};\n\nvar handleEventDispatchErrors$1 = function handleEventDispatchErrors(type, dispatcher) {\n  return function () {\n    try {\n      var result = dispatcher.apply(void 0, arguments);\n\n      if (isPromise(result)) {\n        result.catch(function (err) {\n          logThunkEventListenerError(type, err);\n        });\n      }\n    } catch (err) {\n      logThunkEventListenerError(type, err);\n    }\n  };\n};\n\nfunction createThunkActionsCreator(def, _r) {\n  var actionCreator = function actionCreator(payload) {\n    var dispatchStart = handleEventDispatchErrors$1(def.meta.startType, function () {\n      return _r.dispatch({\n        type: def.meta.startType,\n        payload: payload\n      });\n    });\n    var dispatchFail = handleEventDispatchErrors$1(def.meta.failType, function (err) {\n      return _r.dispatch({\n        type: def.meta.failType,\n        payload: payload,\n        error: err\n      });\n    });\n    var dispatchSuccess = handleEventDispatchErrors$1(def.meta.successType, function (result) {\n      return _r.dispatch({\n        type: def.meta.successType,\n        payload: payload,\n        result: result\n      });\n    });\n    dispatchStart();\n    var failure = null;\n\n    var fail = function fail(_failure) {\n      failure = _failure;\n    };\n\n    var result = _r.dispatch(function () {\n      return def.thunkHandler(payload, fail);\n    });\n\n    if (isPromise(result)) {\n      return result.then(function (resolved) {\n        if (failure) {\n          dispatchFail(failure);\n        } else {\n          dispatchSuccess(resolved);\n        }\n\n        return resolved;\n      });\n    }\n\n    if (failure) {\n      dispatchFail(failure);\n    } else {\n      dispatchSuccess(result);\n    }\n\n    return result;\n  };\n\n  actionCreator.type = def.meta.type;\n  actionCreator.successType = def.meta.successType;\n  actionCreator.failType = def.meta.failType;\n  actionCreator.startType = def.meta.startType;\n  return actionCreator;\n}\n\nfunction createListenerMiddleware(_r) {\n  return function () {\n    return function (next) {\n      return function (action) {\n        var result = next(action);\n\n        if (action && _r._i._lAM[action.type] && _r._i._lAM[action.type].length > 0) {\n          var sourceAction = _r._i._aCD[action.type];\n\n          _r._i._lAM[action.type].forEach(function (actionCreator) {\n            actionCreator({\n              type: sourceAction ? sourceAction.def.meta.type : action.type,\n              payload: action.payload,\n              error: action.error,\n              result: action.result\n            });\n          });\n        }\n\n        return result;\n      };\n    };\n  };\n}\n\nfunction bindListenerdefs(listenerdefs, _aC, _aCD, _lAM) {\n  listenerdefs.forEach(function (def) {\n    var targets = def.targetResolver(get(def.meta.parent, _aC), _aC);\n    var targetTypes = (Array.isArray(targets) ? targets : [targets]).reduce(function (acc, target) {\n      if (typeof target === 'function' && target.def.meta.type && _aCD[target.def.meta.type]) {\n        if (target.def.meta.successType) {\n          acc.push(target.def.meta.successType);\n        } else {\n          acc.push(target.def.meta.type);\n        }\n      } else if (typeof target === 'string') {\n        acc.push(target);\n      }\n\n      return acc;\n    }, []);\n    def.meta.resolvedTargets = targetTypes;\n    targetTypes.forEach(function (targetType) {\n      var listenerReg = _lAM[targetType] || [];\n      listenerReg.push(_aCD[def.meta.type]);\n      _lAM[targetType] = listenerReg;\n    });\n  });\n}\n\nfunction createComputedPropertyBinder(parentPath, key, def, _r) {\n  var runOnce = false;\n  var prevInputs = [];\n  var prevValue;\n  return function createComputedProperty(parentState, storeState) {\n    Object.defineProperty(parentState, key, {\n      configurable: true,\n      enumerable: true,\n      get: function get() {\n        var inputs = def.stateResolvers.map(function (resolver) {\n          return resolver(parentState, storeState);\n        });\n\n        if (runOnce && (areInputsEqual(prevInputs, inputs) || _r._i._cS.isInReducer && new Error().stack.match(/shallowCopy/gi) !== null)) {\n          // We don't want computed properties resolved every time an action\n          // is handled by the reducer. They need to remain lazy, only being\n          // computed when used by a component or getState call.\n          return prevValue;\n        }\n\n        prevInputs = inputs;\n        prevValue = def.fn.apply(def, inputs);\n        runOnce = true;\n        return prevValue;\n      }\n    });\n  };\n}\n\nfunction createComputedPropertiesMiddleware(_r) {\n  return function () {\n    return function (next) {\n      return function (action) {\n        _r._i._cS.isInReducer = true;\n        var result = next(action);\n        _r._i._cS.isInReducer = false;\n        return result;\n      };\n    };\n  };\n}\n\nfunction createEffectsMiddleware(_r) {\n  return function (store) {\n    return function (next) {\n      return function (action) {\n        if (_r._i._e.length === 0) {\n          return next(action);\n        }\n\n        var prevState = store.getState();\n        var result = next(action);\n        var nextState = store.getState();\n\n        _r._i._e.forEach(function (def) {\n          var prevLocal = get(def.meta.parent, prevState);\n          var nextLocal = get(def.meta.parent, nextState);\n\n          if (prevLocal !== nextLocal) {\n            var prevDependencies = def.dependencyResolvers.map(function (resolver) {\n              return resolver(prevLocal);\n            });\n            var nextDependencies = def.dependencyResolvers.map(function (resolver) {\n              return resolver(nextLocal);\n            });\n            var hasChanged = prevDependencies.some(function (dependency, idx) {\n              return dependency !== nextDependencies[idx];\n            });\n\n            if (hasChanged) {\n              def.actionCreator(prevDependencies, nextDependencies, action);\n            }\n          }\n        });\n\n        return result;\n      };\n    };\n  };\n}\n\nvar logEffectError = function logEffectError(err) {\n  // As users can't get a handle on effects we need to report the error\n  // eslint-disable-next-line no-console\n  console.log(err);\n};\n\nfunction createEffectHandler(def, _r, injections, _aC) {\n  var actions = get(def.meta.parent, _aC);\n  var dispose;\n  return function (change) {\n    var helpers = {\n      dispatch: _r.dispatch,\n      getState: function getState() {\n        return get(def.meta.parent, _r.getState());\n      },\n      getStoreActions: function getStoreActions() {\n        return _aC;\n      },\n      getStoreState: _r.getState,\n      injections: injections,\n      meta: {\n        key: def.meta.actionName,\n        parent: def.meta.parent,\n        path: def.meta.path\n      }\n    };\n\n    if (dispose !== undefined) {\n      var disposeResult = dispose();\n      dispose = undefined;\n\n      if (isPromise(disposeResult)) {\n        disposeResult.catch(logEffectError);\n      }\n    }\n\n    var effectResult = def.fn(actions, change, helpers);\n\n    if (isPromise(effectResult)) {\n      return effectResult.then(function (resolved) {\n        if (typeof resolved === 'function') {\n          if (process.env.NODE_ENV !== 'production') {\n            // Dispose functions are not allowed to be resolved asynchronously.\n            // Doing so would provide inconsistent behaviour around their execution.\n            // eslint-disable-next-line no-console\n            console.warn('[easy-peasy] Effect is asynchronously resolving a dispose fn.');\n          }\n        }\n      });\n    }\n\n    if (typeof effectResult === 'function') {\n      dispose = effectResult;\n    }\n\n    return undefined;\n  };\n}\n\nvar logEffectEventListenerError = function logEffectEventListenerError(type, err) {\n  // eslint-disable-next-line no-console\n  console.log(\"Error in \" + type); // eslint-disable-next-line no-console\n\n  console.log(err);\n};\n\nvar handleEventDispatchErrors = function handleEventDispatchErrors(type, dispatcher) {\n  return function () {\n    try {\n      var result = dispatcher.apply(void 0, arguments);\n\n      if (isPromise(result)) {\n        result.catch(function (err) {\n          logEffectEventListenerError(type, err);\n        });\n      }\n    } catch (err) {\n      logEffectEventListenerError(type, err);\n    }\n  };\n};\n\nfunction createEffectActionsCreator(def, _r, effectHandler) {\n  var actionCreator = function actionCreator(previousDependencies, nextDependencies, action) {\n    var change = {\n      prev: previousDependencies,\n      current: nextDependencies,\n      action: action\n    };\n    var dispatchStart = handleEventDispatchErrors(def.meta.startType, function () {\n      return _r.dispatch({\n        type: def.meta.startType,\n        change: change\n      });\n    });\n    var dispatchSuccess = handleEventDispatchErrors(def.meta.successType, function () {\n      return _r.dispatch({\n        type: def.meta.successType,\n        change: change\n      });\n    });\n    dispatchStart();\n\n    try {\n      var result = _r.dispatch(function () {\n        return effectHandler(change);\n      });\n\n      if (isPromise(result)) {\n        return result.then(function (resolved) {\n          dispatchSuccess(resolved);\n          return resolved;\n        }, logEffectError);\n      }\n\n      dispatchSuccess(result);\n      return result;\n    } catch (err) {\n      logEffectError(err);\n    }\n  };\n\n  actionCreator.type = def.meta.type;\n  actionCreator.startType = def.meta.startType;\n  actionCreator.successType = def.meta.successType;\n  actionCreator.failType = def.meta.failType;\n  return actionCreator;\n}\n\nfunction extractDataFromModel(model, initialState, injections, _r) {\n  var _dS = initialState;\n  var _aCD = {};\n  var _aC = {};\n  var _aRD = {};\n  var actionThunks = {};\n  var _cP = [];\n  var _cR = [];\n  var _e = [];\n  var _lAC = {};\n  var _lAM = {};\n  var listenerdefs = [];\n  var _persistenceConfig = [];\n  var _cS = {\n    isInReducer: false\n  };\n\n  var recursiveExtractFromModel = function recursiveExtractFromModel(current, parentPath) {\n    return Object.keys(current).forEach(function (key) {\n      var value = current[key];\n      var path = [].concat(parentPath, [key]);\n      var meta = {\n        parent: parentPath,\n        path: path,\n        key: key\n      };\n\n      var handleValueAsState = function handleValueAsState() {\n        var initialParentRef = get(parentPath, initialState);\n\n        if (initialParentRef && key in initialParentRef) {\n          set(path, _dS, initialParentRef[key]);\n        } else {\n          set(path, _dS, value);\n        }\n      };\n\n      if (key === persistSymbol) {\n        _persistenceConfig.push(extractPersistConfig(parentPath, value));\n\n        return;\n      }\n\n      if (value != null && typeof value === 'object') {\n        if (value[actionSymbol] || value[actionOnSymbol]) {\n          var def = _objectSpread({}, value); // Determine the category of the action\n\n\n          var category = def[actionSymbol] ? '@action' : '@actionOn'; // Establish the meta data describing the action\n\n          def.meta = {\n            actionName: meta.key,\n            category: category,\n            type: category + \".\" + meta.path.join('.'),\n            parent: meta.parent,\n            path: meta.path\n          }; // Create the \"action creator\" function\n\n          def.actionCreator = createActionCreator(def, _r); // Create a bidirectional relationship of the def/actionCreator\n\n          def.actionCreator.def = def; // Create a bidirectional relationship of the def/reducer\n\n          def.fn.def = def; // Add the action creator to lookup map\n\n          _aCD[def.meta.type] = def.actionCreator; // Add the reducer to lookup map\n\n          _aRD[def.meta.type] = def.fn; // We don't want to expose the internal action to consumers\n\n          if (meta.key !== 'ePRS') {\n            // Set the action creator in the \"actions\" object tree for\n            // either the listeners object tree, or the standard actions/thunks\n            // object tree\n            if (def[actionOnSymbol]) {\n              listenerdefs.push(def);\n              set(path, _lAC, def.actionCreator);\n            } else {\n              set(path, _aC, def.actionCreator);\n            }\n          }\n        } else if (value[thunkSymbol] || value[thunkOnSymbol]) {\n          var _def = _objectSpread({}, value); // Determine the category of the thunk\n\n\n          var _category = _def[thunkSymbol] ? '@thunk' : '@thunkOn'; // Establish the meta data describing the thunk\n\n\n          var type = _category + \".\" + meta.path.join('.');\n          _def.meta = {\n            actionName: meta.key,\n            parent: meta.parent,\n            path: meta.path,\n            type: type,\n            startType: type + \"(start)\",\n            successType: type + \"(success)\",\n            failType: type + \"(fail)\"\n          }; // Create the function that will handle, i.e. be executed, when\n          // the thunk action is created/dispatched\n\n          _def.thunkHandler = createThunkHandler(_def, _r, injections, _aC); // Register the thunk handler\n\n          set(path, actionThunks, _def.thunkHandler); // Create the \"action creator\" function\n\n          _def.actionCreator = createThunkActionsCreator(_def, _r); // Create a bidirectional relationship of the def/actionCreator\n\n          _def.actionCreator.def = _def; // Register the action creator within the lookup map\n\n          _aCD[_def.meta.type] = _def.actionCreator; // Set the action creator in the \"actions\" object tree for\n          // either the listeners object tree, or the standard actions/thunks\n          // object tree\n\n          if (_def[thunkOnSymbol]) {\n            listenerdefs.push(_def);\n            set(path, _lAC, _def.actionCreator);\n          } else {\n            set(path, _aC, _def.actionCreator);\n          }\n        } else if (value[computedSymbol]) {\n          var parent = get(parentPath, _dS);\n          var bindComputedProperty = createComputedPropertyBinder(parentPath, key, value, _r);\n          bindComputedProperty(parent, _dS);\n\n          _cP.push({\n            key: key,\n            parentPath: parentPath,\n            bindComputedProperty: bindComputedProperty\n          });\n        } else if (value[reducerSymbol]) {\n          _cR.push({\n            key: key,\n            parentPath: parentPath,\n            reducer: value.fn\n          });\n        } else if (value[effectOnSymbol]) {\n          var _def2 = _objectSpread({}, value); // Establish the meta data describing the effect\n\n\n          var _type = \"@effectOn.\" + meta.path.join('.');\n\n          _def2.meta = {\n            type: _type,\n            actionName: meta.key,\n            parent: meta.parent,\n            path: meta.path,\n            startType: _type + \"(start)\",\n            successType: _type + \"(success)\",\n            failType: _type + \"(fail)\"\n          };\n          var effectHandler = createEffectHandler(_def2, _r, injections, _aC);\n          var actionCreator = createEffectActionsCreator(_def2, _r, effectHandler);\n          _def2.actionCreator = actionCreator;\n\n          _e.push(_def2);\n        } else if (isPlainObject(value)) {\n          var existing = get(path, _dS);\n\n          if (existing == null) {\n            set(path, _dS, {});\n          }\n\n          recursiveExtractFromModel(value, path);\n        } else {\n          handleValueAsState();\n        }\n      } else {\n        handleValueAsState();\n      }\n    });\n  };\n\n  _persistenceConfig = _persistenceConfig.sort(function (a, b) {\n    var aPath = a.path.join('.');\n    var bPath = b.path.join('.');\n\n    if (aPath < bPath) {\n      return -1;\n    }\n\n    if (aPath > bPath) {\n      return 1;\n    }\n\n    return 0;\n  });\n  recursiveExtractFromModel(model, []);\n  bindListenerdefs(listenerdefs, _aC, _aCD, _lAM);\n  return {\n    _aCD: _aCD,\n    _aC: _aC,\n    _aRD: _aRD,\n    _cP: _cP,\n    _cR: _cR,\n    _cS: _cS,\n    _dS: _dS,\n    _e: _e,\n    _lAC: _lAC,\n    _lAM: _lAM,\n    _persistenceConfig: _persistenceConfig\n  };\n}\n\nfunction createStore(model, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var modelClone = clone(model);\n  var _options = options,\n      compose$1 = _options.compose,\n      _options$devTools = _options.devTools,\n      devTools = _options$devTools === void 0 ? process.env.NODE_ENV !== 'production' : _options$devTools,\n      _options$disableImmer = _options.disableImmer,\n      disableImmer = _options$disableImmer === void 0 ? false : _options$disableImmer,\n      _options$enhancers = _options.enhancers,\n      enhancers = _options$enhancers === void 0 ? [] : _options$enhancers,\n      _options$initialState = _options.initialState,\n      initialState = _options$initialState === void 0 ? {} : _options$initialState,\n      _options$injections = _options.injections,\n      injections = _options$injections === void 0 ? {} : _options$injections,\n      _options$middleware = _options.middleware,\n      middleware = _options$middleware === void 0 ? [] : _options$middleware,\n      _options$mockActions = _options.mockActions,\n      mockActions = _options$mockActions === void 0 ? false : _options$mockActions,\n      _options$name = _options.name,\n      storeName = _options$name === void 0 ? \"EasyPeasyStore\" : _options$name,\n      _options$version = _options.version,\n      version = _options$version === void 0 ? 0 : _options$version,\n      _options$reducerEnhan = _options.reducerEnhancer,\n      reducerEnhancer = _options$reducerEnhan === void 0 ? function (rootReducer) {\n    return rootReducer;\n  } : _options$reducerEnhan;\n\n  var bindReplaceState = function bindReplaceState(modelDef) {\n    return _objectSpread(_objectSpread({}, modelDef), {}, {\n      ePRS: action(function (_, payload) {\n        return payload;\n      })\n    });\n  };\n\n  var _r = {};\n  var modeldef = bindReplaceState(modelClone);\n  var mockedActions = [];\n\n  var persistKey = function persistKey(targetPath) {\n    return \"[\" + storeName + \"][\" + version + \"]\" + (targetPath.length > 0 ? \"[\" + targetPath.join('.') + \"]\" : '');\n  };\n\n  var persistor = createPersistor(persistKey, _r);\n  var persistMiddleware = createPersistMiddleware(persistor, _r);\n\n  var replaceState = function replaceState(nextState) {\n    return _r._i._aCD['@action.ePRS'](nextState);\n  };\n\n  var bindStoreInternals = function bindStoreInternals(state) {\n    if (state === void 0) {\n      state = {};\n    }\n\n    var data = extractDataFromModel(modeldef, state, injections, _r);\n    _r._i = _objectSpread(_objectSpread({}, data), {}, {\n      reducer: reducerEnhancer(createReducer(disableImmer, data._aRD, data._cR, data._cP))\n    });\n  };\n\n  var mockActionsMiddleware = function mockActionsMiddleware() {\n    return function () {\n      return function (action) {\n        if (action != null) {\n          mockedActions.push(action);\n        }\n\n        return undefined;\n      };\n    };\n  };\n\n  var composeEnhancers = compose$1 || (devTools && typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({\n    name: storeName\n  }) : compose);\n  bindStoreInternals(initialState);\n  var easyPeasyMiddleware = [createComputedPropertiesMiddleware(_r)].concat(middleware, [reduxThunk, createListenerMiddleware(_r), createEffectsMiddleware(_r), persistMiddleware]);\n\n  if (mockActions) {\n    easyPeasyMiddleware.push(mockActionsMiddleware);\n  }\n\n  var store = createStore$1(_r._i.reducer, _r._i._dS, composeEnhancers.apply(void 0, [applyMiddleware.apply(void 0, easyPeasyMiddleware)].concat(enhancers)));\n  store.subscribe(function () {\n    _r._i._cS.isInReducer = false;\n  });\n  _r.dispatch = store.dispatch;\n  _r.getState = store.getState;\n\n  var bindActionCreators = function bindActionCreators() {\n    Object.keys(store.dispatch).forEach(function (actionsKey) {\n      delete store.dispatch[actionsKey];\n    });\n    Object.keys(_r._i._aC).forEach(function (key) {\n      store.dispatch[key] = _r._i._aC[key];\n    });\n  };\n\n  bindActionCreators();\n\n  var rebindStore = function rebindStore(removeKey) {\n    var currentState = store.getState();\n\n    if (removeKey) {\n      delete currentState[removeKey];\n    }\n\n    bindStoreInternals(currentState);\n    store.replaceReducer(_r._i.reducer);\n    replaceState(_r._i._dS);\n    bindActionCreators();\n  };\n\n  var _resolveRehydration = rehydrateStateFromPersistIfNeeded(persistKey, replaceState, _r);\n\n  return Object.assign(store, {\n    addModel: function addModel(key, modelForKey) {\n      if (modeldef[key] && process.env.NODE_ENV !== 'production') {\n        store.removeModel(key);\n      }\n\n      modeldef[key] = modelForKey;\n      rebindStore(); // There may have been persisted state for a dynamic model. We should try\n      // and rehydrate the specifc node\n\n      var addModelRehydration = rehydrateStateFromPersistIfNeeded(persistKey, replaceState, _r, key);\n      return {\n        resolveRehydration: function resolveRehydration() {\n          return addModelRehydration;\n        }\n      };\n    },\n    clearMockedActions: function clearMockedActions() {\n      mockedActions = [];\n    },\n    getActions: function getActions() {\n      return _r._i._aC;\n    },\n    getListeners: function getListeners() {\n      return _r._i._lAC;\n    },\n    getMockedActions: function getMockedActions() {\n      return [].concat(mockedActions);\n    },\n    persist: {\n      clear: persistor.clear,\n      flush: persistor.flush,\n      resolveRehydration: function resolveRehydration() {\n        return _resolveRehydration;\n      }\n    },\n    reconfigure: function reconfigure(newModel) {\n      modeldef = bindReplaceState(newModel);\n      rebindStore();\n    },\n    removeModel: function removeModel(key) {\n      if (!modeldef[key]) {\n        return;\n      }\n\n      delete modeldef[key];\n      rebindStore(key);\n    }\n  });\n}\n\nfunction createContextStore(model, config) {\n  if (config === void 0) {\n    config = {};\n  } // We create a mutable injections reference to allow updating it\n\n\n  var _config = config,\n      _config$injections = _config.injections,\n      mutableInjections = _config$injections === void 0 ? {} : _config$injections;\n  var StoreContext = createContext();\n\n  function Provider(_ref) {\n    var children = _ref.children,\n        runtimeModel = _ref.runtimeModel,\n        injections = _ref.injections; // If the user provided injections we need to ensure our mutable ref\n    // is up to date. We could consider doing a shallow compare here?\n\n    if (injections != null) {\n      var nextInjections = typeof injections === 'function' ? injections(mutableInjections) : injections;\n      var nextKeys = Object.keys(nextInjections);\n      var removeKeys = Object.keys(mutableInjections).filter(function (k) {\n        return !nextKeys.includes(k);\n      });\n      removeKeys.forEach(function (k) {\n        delete mutableInjections[k];\n      });\n      Object.assign(mutableInjections, nextInjections);\n    }\n\n    var store = useMemoOne(function () {\n      return createStore(typeof model === 'function' ? model(runtimeModel) : model, _objectSpread(_objectSpread({}, config), {}, {\n        originalInjections: mutableInjections\n      }));\n    }, []);\n    return /*#__PURE__*/React.createElement(StoreContext.Provider, {\n      value: store\n    }, children);\n  }\n\n  function useStore() {\n    return useContext(StoreContext);\n  }\n\n  return {\n    Provider: Provider,\n    useStore: useStore,\n    useStoreState: createStoreStateHook(StoreContext),\n    useStoreActions: createStoreActionsHook(StoreContext),\n    useStoreDispatch: createStoreDispatchHook(StoreContext),\n    useStoreRehydrated: createStoreRehydratedHook(StoreContext)\n  };\n}\n/**\n * This file has been copied from redux-persist.\n * The intention being to support as much of the redux-persist API as possible.\n */\n\n\nfunction createTransform(inbound, outbound, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  var whitelist = config.whitelist || null;\n  var blacklist = config.blacklist || null;\n\n  function whitelistBlacklistCheck(key) {\n    if (whitelist && whitelist.indexOf(key) === -1) return true;\n    if (blacklist && blacklist.indexOf(key) !== -1) return true;\n    return false;\n  }\n\n  return {\n    in: function _in(data, key, fullState) {\n      return !whitelistBlacklistCheck(key) && inbound ? inbound(data, key, fullState) : data;\n    },\n    out: function out(data, key, fullState) {\n      return !whitelistBlacklistCheck(key) && outbound ? outbound(data, key, fullState) : data;\n    }\n  };\n}\n/* eslint-disable react/prop-types */\n\n\nfunction StoreProvider(_ref) {\n  var children = _ref.children,\n      store = _ref.store;\n  return /*#__PURE__*/React.createElement(StoreContext.Provider, {\n    value: store\n  }, children);\n}\n\nfunction useLocalStore(modelCreator, dependencies, configCreator) {\n  if (dependencies === void 0) {\n    dependencies = [];\n  }\n\n  var storeRef = useRef();\n  var configRef = useRef();\n  var store = useMemoOne(function () {\n    var previousState = storeRef.current != null ? storeRef.current.getState() : undefined;\n    var config = configCreator != null ? configCreator(previousState, configRef.current) : undefined;\n\n    var _store = createStore(modelCreator(previousState), config);\n\n    configRef.current = config;\n    storeRef.current = _store;\n    return _store;\n  }, dependencies);\n\n  var _useState = useState(function () {\n    return store.getState();\n  }),\n      currentState = _useState[0],\n      setCurrentState = _useState[1];\n\n  useEffect(function () {\n    setCurrentState(store.getState());\n    store.subscribe(function () {\n      var nextState = store.getState();\n\n      if (currentState !== nextState) {\n        setCurrentState(nextState);\n      }\n    });\n  }, [store]);\n  return [currentState, store.getActions(), store];\n}\n\nexport { StoreProvider, action, actionOn, computed, createContextStore, createStore, createStoreActionsHook, createStoreDispatchHook, createStoreRehydratedHook, createStoreStateHook, createTransform, createTypedHooks, debug, generic, persist, reducer, thunk, thunkOn, unstable_effectOn, useLocalStore, useStore, useStoreActions, useStoreDispatch, useStoreRehydrated, useStoreState };","map":{"version":3,"mappings":";;;;;AAEA,IAAMA,YAAY,GAAGC,aAAa,EAAlC,C,CCSA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAMC,yBAAyB,GAC7B,OAAOC,MAAP,KAAkB,WAAlB,GAAgCC,eAAhC,GAAkDC,SADpD;;AAGO,SAASC,oBAAT,CAA8BC,OAA9B,EAAuC;AAC5C,SAAO,SAASC,aAAT,CAAuBC,QAAvB,EAAiCC,UAAjC,EAA6C;AAClD,QAAMC,KAAK,GAAGC,UAAU,CAACL,OAAD,CAAxB;AACA,QAAMM,WAAW,GAAGC,MAAM,CAACL,QAAD,CAA1B;AACA,QAAMM,QAAQ,GAAGD,MAAM,EAAvB;AACA,QAAME,UAAU,GAAGF,MAAM,CAAC,IAAD,CAAzB;AACA,QAAMG,yBAAyB,GAAGH,MAAM,EAAxC;;AAEA,sBAAwBI,UAAU,CAAC,UAACC,CAAD;AAAA,aAAOA,CAAC,GAAG,CAAX;AAAD,OAAe,CAAf,CAAlC;AAAA,QAASC,WAAT;;AAEA,QACEH,yBAAyB,CAACI,OAA1BJ,IACAJ,WAAW,CAACQ,OAAZR,KAAwBJ,QADxBQ,IAEAF,QAAQ,CAACM,OAATN,KAAqBO,SAHvB,EAIE;AACA,UAAI;AACFP,gBAAQ,CAACM,OAATN,GAAmBN,QAAQ,CAACE,KAAK,CAACY,QAANZ,EAAD,CAA3BI;AADF,QAEE,OAAOS,GAAP,EAAY;AACZ,YAAIC,OAAO,CAACC,GAARD,CAAYE,QAAZF,KAAyB,aAA7B,EAA4C;AAC1C,cAAIG,YAAY,gCAA8BJ,GAAG,CAACK,OAAlC,MAAhB;;AACA,cAAIZ,yBAAyB,CAACI,OAA9B,EAAuC;AACrCO,wBAAY,8BAA4BX,yBAAyB,CAACI,OAA1BJ,CAAkCa,KAA1EF;AACD;;AACD,gBAAM,IAAIG,KAAJ,CAAUH,YAAV,CAAN;AACD;;AACD,cAAMX,yBAAyB,CAACI,OAA1BJ,IAAqCO,GAA3C;AACD;AACF;;AAEDtB,6BAAyB,CAAC,YAAM;AAC9BW,iBAAW,CAACQ,OAAZR,GAAsBJ,QAAtBI;AACAI,+BAAyB,CAACI,OAA1BJ,GAAoCK,SAApCL;AAFuB,MAAzBf;AAKAA,6BAAyB,CAAC,YAAM;AAC9B,UAAM8B,aAAa,GAAG,SAAhBA,aAAgB,GAAM;AAC1B,YAAI;AACF,cAAMC,QAAQ,GAAGpB,WAAW,CAACQ,OAAZR,CAAoBF,KAAK,CAACY,QAANZ,EAApBE,CAAjB;AAEA,cAAMqB,YAAY,GAChB,OAAOxB,UAAP,KAAsB,UAAtB,GACIA,UAAU,CAACK,QAAQ,CAACM,OAAV,EAAmBY,QAAnB,CADd,GAEIlB,QAAQ,CAACM,OAATN,KAAqBkB,QAH3B;;AAKA,cAAIC,YAAJ,EAAkB;AAChB;AACD;;AAEDnB,kBAAQ,CAACM,OAATN,GAAmBkB,QAAnBlB;AAZF,UAaE,OAAOS,GAAP,EAAY;AACZ;AACA;AACA;AACA;AACAP,mCAAyB,CAACI,OAA1BJ,GAAoCO,GAApCP;AACD;;AACD,YAAID,UAAU,CAACK,OAAf,EAAwB;AACtBD,qBAAW,CAAC,EAAD,CAAXA;AACD;AAvBH;;AAyBA,UAAMe,WAAW,GAAGxB,KAAK,CAACyB,SAANzB,CAAgBqB,aAAhBrB,CAApB;AACAqB,mBAAa;AACb,aAAO,YAAM;AACXhB,kBAAU,CAACK,OAAXL,GAAqB,KAArBA;AACAmB,mBAAW;AAFb;AA5BuB,OAgCtB,EAhCsB,CAAzBjC;AAkCA,WAAOa,QAAQ,CAACM,OAAhB;AAnEF;AAqED;;IAEYb,aAAa,GAAGF,oBAAoB,CAAC+B,YAAD;;AAE1C,SAASC,sBAAT,CAAgC/B,OAAhC,EAAyC;AAC9C,SAAO,SAASgC,eAAT,CAAyBC,UAAzB,EAAqC;AAC1C,QAAM7B,KAAK,GAAGC,UAAU,CAACL,OAAD,CAAxB;AACA,WAAOiC,UAAU,CAAC7B,KAAK,CAAC8B,UAAN9B,EAAD,CAAjB;AAFF;AAID;;IAEY4B,eAAe,GAAGD,sBAAsB,CAACD,YAAD;;AAE9C,SAASK,uBAAT,CAAiCnC,OAAjC,EAA0C;AAC/C,SAAO,SAASoC,gBAAT,GAA4B;AACjC,QAAMhC,KAAK,GAAGC,UAAU,CAACL,OAAD,CAAxB;AACA,WAAOI,KAAK,CAACiC,QAAb;AAFF;AAID;;IAEYD,gBAAgB,GAAGD,uBAAuB,CAACL,YAAD;;AAEhD,SAASQ,QAAT,GAAoB;AACzB,SAAOjC,UAAU,CAACyB,YAAD,CAAjB;AACD;;AAEM,SAASS,yBAAT,CAAmCvC,OAAnC,EAA4C;AACjD,SAAO,SAASwC,kBAAT,GAA8B;AACnC,QAAMpC,KAAK,GAAGC,UAAU,CAACL,OAAD,CAAxB;;AACA,oBAAoCyC,QAAQ,CAAC,KAAD,CAA5C;AAAA,QAAOC,UAAP;AAAA,QAAmBC,aAAnB;;AACA7C,aAAS,CAAC,YAAM;AACdM,WAAK,CAACwC,OAANxC,CAAcyC,kBAAdzC,GAAmC0C,IAAnC1C,CAAwC;AAAA,eAAMuC,aAAa,CAAC,IAAD,CAAnB;AAAxC;AADO,OAEN,EAFM,CAAT7C;AAGA,WAAO4C,UAAP;AANF;AAQD;;IAEYF,kBAAkB,GAAGD,yBAAyB,CAACT,YAAD;;AAEpD,SAASiB,gBAAT,GAA4B;AACjC,SAAO;AACLf,mBAAe,EAAfA,eADK;AAELI,oBAAgB,EAAhBA,gBAFK;AAGLnC,iBAAa,EAAbA,aAHK;AAILuC,sBAAkB,EAAlBA,kBAJK;AAKLF,YAAQ,EAARA;AALK,GAAP;AAOD;;AC1IM,IAAMU,YAAY,GAAG,KAArB;AACA,IAAMC,cAAc,GAAG,MAAvB;AACA,IAAMC,cAAc,GAAG,KAAvB;AACA,IAAMC,cAAc,GAAG,KAAvB;AACA,IAAMC,aAAa,GAAG,KAAtB;AACA,IAAMC,aAAa,GAAG,KAAtB;AACA,IAAMC,aAAa,GAAG,MAAtB;AACA,IAAMC,WAAW,GAAG,KAApB;;ICKMC,KAAK,GAAG,SAARA,KAAQ,CAACC,KAAD,EAAW;AAC9B,MAAIC,OAAO,CAACD,KAAD,CAAX,EAAoB;AAClB,WAAO3C,OAAO,CAAC2C,KAAD,CAAd;AACD;;AACD,SAAOA,KAAP;AACD;;IAEYE,QAAQ,GAAG,SAAXA,QAAW,CAACC,cAAD,EAAiBC,EAAjB;AAAA;;AAAA,yBACrBZ,cADqB,IACJ,IADI,OAEtBY,EAFsB,GAEtBA,EAFsB,OAGtBD,cAHsB,GAGtBA,cAHsB;AAAA;;IAMXE,MAAM,GAAG,SAATA,MAAS,CAACD,EAAD;AAAA;;AAAA,2BACnBb,YADmB,IACJ,IADI,QAEpBa,EAFoB,GAEpBA,EAFoB;AAAA;;AAKtB,IAAME,qBAAqB,GAAG,CAAC,UAACN,KAAD;AAAA,SAAWA,KAAX;AAAD,EAA9B;;IAEaO,QAAQ,GAAG,SAAXA,QAAW,CAACC,kBAAD,EAAqBJ,EAArB,EAA4B;AAAA;;AAClD,MAAI,OAAOA,EAAP,KAAc,UAAlB,EAA8B;AAAA;;AAC5B,6BACGX,cADH,IACoB,IADpB,QAEEW,EAFF,GAEEA,EAFF,QAGEK,cAHF,GAGkBD,kBAHlB;AAKD;;AACD,2BACGf,cADH,IACoB,IADpB,QAEEW,EAFF,GAEMI,kBAFN,QAGEC,cAHF,GAGkBH,qBAHlB;AAKD;;AAEM,SAASI,iBAAT,CAA2BC,mBAA3B,EAAgDP,EAAhD,EAAoD;AAAA;;AACzD,2BACGV,cADH,IACoB,IADpB,QAEEiB,mBAFF,GAEEA,mBAFF,QAGEP,EAHF,GAGEA,EAHF;AAKD;;AAEM,SAASQ,OAAT,CAAiBC,KAAjB,EAAwB;AAC7B,SAAOA,KAAP;AACD;;IAEY1B,OAAO,GAAG,SAAVA,OAAU,CAAC2B,KAAD,EAAQC,MAAR;AAAA;;AAAA;AAErB,WAAO5E,MAAP,KAAkB,WAAlB,GACI2E,KADJ,mCAGSA,KAHT,4CAIOnB,aAJP,IAIuBoB,MAJvB;AAFqB;AAAA;;IASVC,OAAO,GAAG,SAAVA,OAAU,CAACb,cAAD,EAAiBC,EAAjB;AAAA;;AAAA,2BACpBP,aADoB,IACJ,IADI,QAErBO,EAFqB,GAErBA,EAFqB,QAGrBD,cAHqB,GAGrBA,cAHqB;AAAA;;IAMVc,KAAK,GAAG,SAARA,KAAQ,CAACb,EAAD;AAAA;;AAAA,2BAClBN,WADkB,IACJ,IADI,QAEnBM,EAFmB,GAEnBA,EAFmB;AAAA;;IAKRc,OAAO,GAAG,SAAVA,OAAU,CAACd,EAAD;AAAA;;AAAA,2BACpBR,aADoB,IACJ,IADI,QAErBQ,EAFqB,GAErBA,EAFqB;AAAA;AC5EvB;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAIe,cAAJ;;AAEO,SAASC,aAAT,CAAuBC,GAAvB,EAA4B;AACjC,MAAI,OAAOA,GAAP,KAAe,QAAf,IAA2BA,GAAG,KAAK,IAAvC,EAA6C,OAAO,KAAP;AAE7C,MAAIC,KAAK,GAAGD,GAAZ;;AACA,SAAOE,MAAM,CAACC,cAAPD,CAAsBD,KAAtBC,MAAiC,IAAxC,EAA8C;AAC5CD,SAAK,GAAGC,MAAM,CAACC,cAAPD,CAAsBD,KAAtBC,CAARD;AACD;;AAED,SAAOC,MAAM,CAACC,cAAPD,CAAsBF,GAAtBE,MAA+BD,KAAtC;AACD;;AAEM,SAASG,KAAT,CAAeC,MAAf,EAAuB;AAC5B,WAASC,cAAT,CAAwBtE,OAAxB,EAAiC;AAC/B,QAAMuE,IAAI,GAAGL,MAAM,CAACM,IAAPN,CAAYlE,OAAZkE,EAAqBO,MAArBP,CAA4B,UAACQ,GAAD,EAAMC,GAAN,EAAc;AACrD,UAAIT,MAAM,CAACU,wBAAPV,CAAgClE,OAAhCkE,EAAyCS,GAAzCT,EAA8CW,GAA9CX,IAAqD,IAAzD,EAA+D;AAC7DQ,WAAG,CAACC,GAAD,CAAHD,GAAW1E,OAAO,CAAC2E,GAAD,CAAlBD;AACD;;AACD,aAAOA,GAAP;AAJW,OAKV,EALUR,CAAb;AAMAA,UAAM,CAACM,IAAPN,CAAYK,IAAZL,EAAkBY,OAAlBZ,CAA0B,UAACS,GAAD,EAAS;AACjC,UAAIZ,aAAa,CAACQ,IAAI,CAACI,GAAD,CAAL,CAAjB,EAA8B;AAC5BJ,YAAI,CAACI,GAAD,CAAJJ,GAAYD,cAAc,CAACC,IAAI,CAACI,GAAD,CAAL,CAA1BJ;AACD;AAHH;AAKA,WAAOA,IAAP;AACD;;AACD,SAAOD,cAAc,CAACD,MAAD,CAArB;AACD;;AAEM,SAASU,SAAT,CAAmBC,CAAnB,EAAsB;AAC3B,SAAOA,CAAC,IAAI,IAALA,IAAa,OAAOA,CAAP,KAAa,QAA1BA,IAAsC,OAAOA,CAAC,CAAChD,IAAT,KAAkB,UAA/D;AACD;;AAEM,SAAS6C,GAAT,CAAaI,IAAb,EAAmBC,MAAnB,EAA2B;AAChC,SAAOD,IAAI,CAACR,MAALQ,CACL,UAACP,GAAD,EAAMS,GAAN;AAAA,WAAepB,aAAa,CAACW,GAAD,CAAbX,GAAqBW,GAAG,CAACS,GAAD,CAAxBpB,GAAgC9D,SAA/C;AADK,KAELiF,MAFKD,CAAP;AAID;;AAEM,SAASG,MAAT,CAAgBC,WAAhB,EAA6BC,YAA7B,EAA2CC,UAA3C,EAAuD;AAC5D,MAAIF,WAAW,CAACG,MAAZH,KAAuB,CAA3B,EAA8B;AAC5B,WAAOE,UAAP;AACD;;AACD,MAAM3E,QAAQ,qBAAQ0E,YAAR,CAAd;;AACA,MAAMX,GAAG,GAAGU,WAAW,CAAC,CAAD,CAAvB;;AACA,MAAIA,WAAW,CAACG,MAAZH,KAAuB,CAA3B,EAA8B;AAC5BzE,YAAQ,CAAC+D,GAAD,CAAR/D,GAAgB2E,UAAhB3E;AADF,SAEO;AACLA,YAAQ,CAAC+D,GAAD,CAAR/D,GAAgBwE,MAAM,CAACC,WAAW,CAACI,KAAZJ,CAAkB,CAAlBA,CAAD,EAAuBzE,QAAQ,CAAC+D,GAAD,CAA/B,EAAsCY,UAAtC,CAAtB3E;AACD;;AACD,SAAOA,QAAP;AACD;;AAEM,SAAS8E,GAAT,CAAaT,IAAb,EAAmBC,MAAnB,EAA2B1B,KAA3B,EAAkC;AACvC,MAAIyB,IAAI,CAACO,MAALP,KAAgB,CAApB,EAAuB;AACrB,QAAI,OAAOzB,KAAP,KAAiB,QAArB,EAA+B;AAC7BU,YAAM,CAACM,IAAPN,CAAYgB,MAAZhB,EAAoBY,OAApBZ,CAA4B,UAACS,GAAD,EAAS;AACnC,eAAOO,MAAM,CAACP,GAAD,CAAb;AADF;AAGAT,YAAM,CAACM,IAAPN,CAAYV,KAAZU,EAAmBY,OAAnBZ,CAA2B,UAACS,GAAD,EAAS;AAClCO,cAAM,CAACP,GAAD,CAANO,GAAc1B,KAAK,CAACmB,GAAD,CAAnBO;AADF;AAGD;;AACD;AACD;;AACDD,MAAI,CAACR,MAALQ,CAAY,UAACP,GAAD,EAAMS,GAAN,EAAWQ,GAAX,EAAmB;AAC7B,QAAIA,GAAG,GAAG,CAANA,KAAYV,IAAI,CAACO,MAArB,EAA6B;AAC3Bd,SAAG,CAACS,GAAD,CAAHT,GAAWlB,KAAXkB;AADF,WAEO;AACLA,SAAG,CAACS,GAAD,CAAHT,GAAWA,GAAG,CAACS,GAAD,CAAHT,IAAY,EAAvBA;AACD;;AACD,WAAOA,GAAG,CAACS,GAAD,CAAV;AANF,KAOGD,MAPHD;AAQD;;AAEM,SAASW,mBAAT,CAA6BC,YAA7B,EAAmD;AAAA,MAAtBA,YAAsB;AAAtBA,gBAAsB,GAAP,KAAfA;AAAsB;;AACxD,SAAO,SAASC,aAAT,CAAuBb,IAAvB,EAA6BtC,KAA7B,EAAoCI,EAApC,EAAwC;AAC7C,QAAI8C,YAAJ,EAAkB;AAChB,UAAM7F,QAAO,GAAG6E,GAAG,CAACI,IAAD,EAAOtC,KAAP,CAAnB;;AACA,UAAM4B,IAAI,GAAGxB,EAAE,CAAC/C,QAAD,CAAf;;AACA,UAAIA,QAAO,KAAKuE,IAAhB,EAAsB;AACpB,eAAOa,MAAM,CAACH,IAAD,EAAOtC,KAAP,EAAc4B,IAAd,CAAb;AACD;;AACD,aAAO5B,KAAP;AACD;;AACD,QAAI,CAACmB,cAAL,EAAqB;AACnBA,oBAAc,GAAG,IAAIiC,KAAJ,CAAU;AACzB;AACA;AACA;AACAC,kBAAU,EACR,OAAOC,KAAP,KAAiB,WAAjB,IACA,OAAOA,KAAK,CAACC,SAAb,KAA2B,WAD3B,IAEA,OAAOC,OAAP,KAAmB,WAPI;AAQzB;AACA;AACAC,kBAAU,EAAE;AAVa,OAAV,CAAjBtC;AAYD;;AACD,QAAImB,IAAI,CAACO,MAALP,KAAgB,CAApB,EAAuB;AACrB,UAAMoB,MAAK,GAAGvC,cAAc,CAACwC,WAAfxC,CAA2BnB,KAA3BmB,CAAd;;AACA,UAAMyC,OAAM,GAAGxD,EAAE,CAACsD,MAAD,CAAjB;;AACA,UAAIE,OAAJ,EAAY;AACV,eAAO3D,OAAO,CAAC2D,OAAD,CAAP3D,GAAkBkB,cAAc,CAAC0C,WAAf1C,CAA2ByC,OAA3BzC,CAAlBlB,GAAuD2D,OAA9D;AACD;;AACD,aAAOzC,cAAc,CAAC0C,WAAf1C,CAA2BuC,MAA3BvC,CAAP;AACD;;AACD,QAAM2C,UAAU,GAAGxB,IAAI,CAACQ,KAALR,CAAW,CAAXA,EAAcA,IAAI,CAACO,MAALP,GAAc,CAA5BA,CAAnB;AACA,QAAMoB,KAAK,GAAGvC,cAAc,CAACwC,WAAfxC,CAA2BnB,KAA3BmB,CAAd;AACA,QAAM4C,MAAM,GAAG7B,GAAG,CAAC4B,UAAD,EAAa9D,KAAb,CAAlB;AACA,QAAM3C,OAAO,GAAG6E,GAAG,CAACI,IAAD,EAAOoB,KAAP,CAAnB;AACA,QAAME,MAAM,GAAGxD,EAAE,CAAC/C,OAAD,CAAjB;;AAEA,QAAIuG,MAAJ,EAAY;AACVG,YAAM,CAACzB,IAAI,CAACA,IAAI,CAACO,MAALP,GAAc,CAAf,CAAL,CAANyB,GAAgCH,MAAhCG;AACD;;AACD,WAAO5C,cAAc,CAAC0C,WAAf1C,CAA2BuC,KAA3BvC,CAAP;AAxCF;AA0CD;;AAED,IAAM6C,OAAO,GAAG,SAAVA,OAAU,CAACC,QAAD,EAAW/C,OAAX,EAAoBgD,YAApB;AAAA,SACd,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AAC/B,QAAMC,QAAQ,GAAGL,QAAQ,CAACM,MAAM,CAACD,QAAR,CAARL,EAAjB;AACA,QAAIO,KAAK,GAAG,CAAZ;;AAEA,QAAM5C,IAAI,GAAG,SAAPA,IAAO,CAAC6C,KAAD,EAAW;AACtB,UAAMC,OAAO,GAAGJ,QAAQ,CAAC1C,IAAT0C,EAAhB;;AAEA,UAAII,OAAO,CAACC,IAAZ,EAAkB;AAChBP,eAAO,CAACK,KAAD,CAAPL;AACA;AACD;;AAEDD,aAAO,CAACS,GAART,CAAY,CAACM,KAAD,EAAQC,OAAO,CAAC7D,KAAhB,CAAZsD,EACG9E,IADH8E,CACQ,UAACtD,KAAD;AAAA;AAEJe,cAAI,CAACV,OAAO,CAACL,KAAK,CAAC,CAAD,CAAN,EAAWA,KAAK,CAAC,CAAD,CAAhB,EAAqB2D,KAAK,EAA1B,CAAR;AAFA;AADR,SAKGK,KALHV,CAKS,UAAC3G,GAAD;AAAA,eAAS6G,MAAM,CAAC7G,GAAD,CAAf;AALT;AARF;;AAgBAoE,QAAI,CAACsC,YAAD,CAAJtC;AApBF,IADc;AAAhB;;AAwBO,IAAMkD,OAAO,GAAG,SAAVA,OAAU,CAACC,KAAD,EAAW;AAChC,MAAMC,OAAO,GAAG,EAAhB;AACA,SAAOhB,OAAO,CAACe,KAAD,EAAQ,UAACE,CAAD,EAAIC,IAAJ;AAAA,WACpBA,IAAI,GAAG7F,IAAP6F,CAAY,UAACrE,KAAD,EAAW;AACrBmE,aAAO,CAACG,IAARH,CAAanE,KAAbmE;AADF,MADoB;AAAR,IAAPhB,CAIL3E,IAJK2E,CAIA;AAAA,WAAMgB,OAAN;AAJA,IAAP;AAFK;;AASA,SAASI,cAAT,CAAwBC,SAAxB,EAAmCC,UAAnC,EAA+C;AACpD,MAAID,SAAS,CAACxC,MAAVwC,KAAqBC,UAAU,CAACzC,MAApC,EAA4C;AAC1C,WAAO,KAAP;AACD;;AACD,OAAK,IAAI0C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,SAAS,CAACxC,MAA9B,EAAsC0C,CAAC,IAAI,CAA3C,EAA8C;AAC5C,QAAIF,SAAS,CAACE,CAAD,CAATF,KAAiBC,UAAU,CAACC,CAAD,CAA/B,EAAoC;AAClC,aAAO,KAAP;AACD;AACF;;AACD,SAAO,IAAP;AACD,C,CAAA;AAGD;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEO,SAASC,UAAT;AAELC,SAFK;AAILC,MAJK,EAKL;AACA;AACA,MAAMC,OAAO,GAAGC,KAAK,CAAC5G,QAAN4G,CAAe;AAAA,WAAO;AACpCF,YAAM,EAANA,MADoC;AAEpC9B,YAAM,EAAE6B,SAAS;AAFmB,KAAP;AAAf,KAGZ,CAHYG,CAAhB;AAKA,MAAMC,SAAS,GAAGD,KAAK,CAAC9I,MAAN8I,CAAaD,OAAbC,CAAlB,CAPA;;AAWA,MAAME,YAAY,GAAGC,OAAO,CAC1BL,MAAM,IACJG,SAAS,CAACxI,OAAVwI,CAAkBH,MADpBA,IAEEN,cAAc,CAACM,MAAD,EAASG,SAAS,CAACxI,OAAVwI,CAAkBH,MAA3B,CAHU,CAA5B,CAXA;;AAkBA,MAAMM,KAAK,GAAGF,YAAY,GACtBD,SAAS,CAACxI,OADY,GAEtB;AACEqI,UAAM,EAANA,MADF;AAEE9B,UAAM,EAAE6B,SAAS;AAFnB,GAFJ,CAlBA;;AA0BAG,OAAK,CAACvJ,SAANuJ,CAAgB,YAAM;AACpBC,aAAS,CAACxI,OAAVwI,GAAoBG,KAApBH;AADF,KAEG,CAACG,KAAD,CAFHJ;AAIA,SAAOI,KAAK,CAACpC,MAAb;AACD;;AClOc,SAASqC,aAAT,CAAuB/C,YAAvB,EAAqCgD,IAArC,EAA2CC,GAA3C,EAAgDC,GAAhD,EAAqD;AAClE,MAAMjD,aAAa,GAAGF,mBAAmB,CAACC,YAAD,CAAzC;;AAEA,MAAMmD,sBAAsB,GAAG,SAAzBA,sBAAyB,CAACrG,KAAD,EAAQK,MAAR,EAAgBiG,aAAhB,EAA+BhE,IAA/B;AAAA,WAC7Ba,aAAa,CAACb,IAAD,EAAOtC,KAAP,EAAc,UAAC0D,KAAD;AAAA,aAAW4C,aAAa,CAAC5C,KAAD,EAAQrD,MAAM,CAACkG,OAAf,CAAxB;AAAd,MADgB;AAA/B;;AAGA,MAAMC,iBAAiB,GAAG,SAApBA,iBAAoB,CAACxG,KAAD,EAAQK,MAAR,EAAmB;AAC3C,QAAMiG,aAAa,GAAGJ,IAAI,CAAC7F,MAAM,CAACoG,IAAR,CAA1B;;AACA,QAAIH,aAAJ,EAAmB;AACjB,aAAOD,sBAAsB,CAC3BrG,KAD2B,EAE3BK,MAF2B,EAG3BiG,aAH2B,EAI3BA,aAAa,CAACI,GAAdJ,CAAkBK,IAAlBL,CAAuBvC,MAJI,CAA7B;AAMD;;AACD,WAAO/D,KAAP;AAVF;;AAaA,MAAM4G,wBAAwB,GAAG,SAA3BA,wBAA2B,CAAC5G,KAAD,EAAQK,MAAR;AAAA,WAC/B8F,GAAG,CAACrE,MAAJqE,CACE,UAACpE,GAAD;AAAA,UAAQ+B,UAAR,QAAQA,UAAR;AAAA,UAAoB9B,GAApB,QAAoBA,GAApB;AAAA,UAAyBd,OAAzB,QAAyBA,OAAzB;AAAA,aACEiC,aAAa,CAACW,UAAD,EAAa/B,GAAb,EAAkB,UAAC2B,KAAD,EAAW;AACxCA,aAAK,CAAC1B,GAAD,CAAL0B,GAAaxC,OAAO,CAClBjB,OAAO,CAACyD,KAAK,CAAC1B,GAAD,CAAN,CAAP/B,GAAsB4G,QAAQ,CAACnD,KAAK,CAAC1B,GAAD,CAAN,CAA9B/B,GAA6CyD,KAAK,CAAC1B,GAAD,CADhC,EAElB3B,MAFkB,CAApBqD;AAIA,eAAOA,KAAP;AALW,QADf;AADF,OASE1D,KATFmG,CAD+B;AAAjC;;AAaA,MAAMW,WAAW,GAAG,SAAdA,WAAc,CAAC9G,KAAD,EAAQK,MAAR,EAAmB;AACrC,QAAM0G,iBAAiB,GAAGP,iBAAiB,CAACxG,KAAD,EAAQK,MAAR,CAA3C;AACA,QAAMuB,IAAI,GACRuE,GAAG,CAACtD,MAAJsD,GAAa,CAAbA,GACIS,wBAAwB,CAACG,iBAAD,EAAoB1G,MAApB,CAD5B8F,GAEIY,iBAHN;;AAIA,QAAI/G,KAAK,KAAK4B,IAAd,EAAoB;AAClBwE,SAAG,CAACjE,OAAJiE,CAAY,iBAA0C;AAAA,YAAvCtC,UAAuC,SAAvCA,UAAuC;AAAA,YAA3BkD,oBAA2B,SAA3BA,oBAA2B;AACpD,YAAMC,WAAW,GAAG/E,GAAG,CAAC4B,UAAD,EAAalC,IAAb,CAAvB;AACA,YAAIqF,WAAW,IAAI,IAAnB,EAAyBD,oBAAoB,CAACC,WAAD,EAAcrF,IAAd,CAApBoF;AAF3B;AAID;;AACD,WAAOpF,IAAP;AAZF;;AAeA,SAAOkF,WAAP;AACD;;ACjDD,IAAMI,WAAW,GAAG;AAClBC,SAAO,EAAE;AAAA,WAAM7J,SAAN;AADS;AAElB8J,SAAO,EAAE;AAAA,WAAM9J,SAAN;AAFS;AAGlB+J,YAAU,EAAE;AAAA,WAAM/J,SAAN;AAAA;AAHM,CAApB;;AAMA,IAAMgK,gBAAgB,GAAG,SAAnBA,gBAAmB,CAACC,WAAD,EAAiB;AACxC,MAAIC,YAAJ;AACA,SAAO,YAAM;AACX,QAAI,CAACA,YAAL,EAAmB;AACjB,UAAI;AACF,YACE,OAAOrL,MAAP,KAAkB,WAAlB,IACA,OAAOA,MAAM,CAACoL,WAAD,CAAb,KAA+B,WAFjC,EAGE;AACAC,sBAAY,GAAGrL,MAAM,CAACoL,WAAD,CAArBC;AACD;AANH,QAOE,OAAOvC,CAAP,EAAU;AAEX;;AACD,UAAI,CAACuC,YAAL,EAAmB;AACjBA,oBAAY,GAAGN,WAAfM;AACD;AACF;;AAED,WAAOA,YAAP;AAjBF;AAFF;;AAuBA,IAAMC,YAAY,GAAGH,gBAAgB,CAAC,cAAD,CAArC;AACA,IAAMI,cAAc,GAAGJ,gBAAgB,CAAC,gBAAD,CAAvC;;AAEA,SAASK,oBAAT,CAA8BC,OAA9B,EAAuCC,YAAvC,EAA0D;AAAA,MAAnBA,YAAmB;AAAnBA,gBAAmB,GAAJ,EAAfA;AAAmB;;AACxD,MAAID,OAAO,IAAI,IAAf,EAAqB;AACnBA,WAAO,GAAGF,cAAc,EAAxBE;AACD;;AAED,MAAI,OAAOA,OAAP,KAAmB,QAAvB,EAAiC;AAC/B,QAAIA,OAAO,KAAK,cAAhB,EAAgC;AAC9BA,aAAO,GAAGH,YAAY,EAAtBG;AADF,WAEO,IAAIA,OAAO,KAAK,gBAAhB,EAAkC;AACvCA,aAAO,GAAGF,cAAc,EAAxBE;AADK,WAEA;AACL,UAAInK,OAAO,CAACC,GAARD,CAAYE,QAAZF,KAAyB,aAA7B,EAA4C;AAC1CqK,eAAO,CAACC,IAARD;AACD;;AACDF,aAAO,GAAGV,WAAVU;AACD;AACF;;AAED,MAAMI,eAAe,GAAG,UAAIH,YAAJ,EAAkBI,OAAlB,EAAxB;;AAEA,MAAMC,SAAS,GAAG,SAAZA,SAAY,CAACC,IAAD,EAAU;AAC1B,QAAIN,YAAY,CAAChF,MAAbgF,GAAsB,CAAtBA,IAA2BM,IAAI,IAAI,IAAnCN,IAA2C,OAAOM,IAAP,KAAgB,QAA/D,EAAyE;AACvE5G,YAAM,CAACM,IAAPN,CAAY4G,IAAZ5G,EAAkBY,OAAlBZ,CAA0B,UAACS,GAAD,EAAS;AACjCmG,YAAI,CAACnG,GAAD,CAAJmG,GAAYN,YAAY,CAAC/F,MAAb+F,CACV,UAAC9F,GAAD,EAAMS,GAAN;AAAA,iBAAcA,GAAG,CAAC4F,EAAJ5F,CAAOT,GAAPS,EAAYR,GAAZQ,CAAd;AADU,WAEV2F,IAAI,CAACnG,GAAD,CAFM6F,CAAZM;AADF;AAMD;;AAED,WAAOP,OAAO,KAAKH,YAAY,EAAxBG,IAA8BA,OAAO,KAAKF,cAAc,EAAxDE,GACHS,IAAI,CAACC,SAALD,CAAe;AAAEF,UAAI,EAAJA;AAAF,KAAfE,CADGT,GAEHO,IAFJ;AAVF;;AAeA,MAAMI,WAAW,GAAG,SAAdA,WAAc,CAACJ,IAAD,EAAU;AAC5B,QAAMvE,MAAM,GACVgE,OAAO,KAAKH,YAAY,EAAxBG,IAA8BA,OAAO,KAAKF,cAAc,EAAxDE,GACIS,IAAI,CAACG,KAALH,CAAWF,IAAXE,EAAiBF,IADrBP,GAEIO,IAHN;;AAIA,QACEH,eAAe,CAACnF,MAAhBmF,GAAyB,CAAzBA,IACApE,MAAM,IAAI,IADVoE,IAEA,OAAOpE,MAAP,KAAkB,QAHpB,EAIE;AACArC,YAAM,CAACM,IAAPN,CAAYqC,MAAZrC,EAAoBY,OAApBZ,CAA4B,UAACS,GAAD,EAAS;AACnC4B,cAAM,CAAC5B,GAAD,CAAN4B,GAAcoE,eAAe,CAAClG,MAAhBkG,CACZ,UAACjG,GAAD,EAAMS,GAAN;AAAA,iBAAcA,GAAG,CAACiG,GAAJjG,CAAQT,GAARS,EAAaR,GAAbQ,CAAd;AADY,WAEZoB,MAAM,CAAC5B,GAAD,CAFMgG,CAAdpE;AADF;AAMD;;AACD,WAAOA,MAAP;AAjBF;;AAoBA,MAAM8E,OAAO,GAAGtG,SAAS,CAACwF,OAAO,CAACT,OAARS,CAAgB,GAAhBA,CAAD,CAAzB;AAEA,SAAO;AACLT,WAAO,EAAE,iBAACnF,GAAD,EAAS;AAChB,UAAI0G,OAAJ,EAAa;AACX,eAAOd,OAAO,CACXT,OADIS,CACI5F,GADJ4F,EAEJvI,IAFIuI,CAEC,UAACe,OAAD;AAAA,iBACJA,OAAO,IAAI,IAAXA,GAAkBJ,WAAW,CAACI,OAAD,CAA7BA,GAAyCrL,SADrC;AAFD,UAAP;AAKD;;AACD,UAAMqL,OAAO,GAAGf,OAAO,CAACT,OAARS,CAAgB5F,GAAhB4F,CAAhB;AACA,aAAOe,OAAO,IAAI,IAAXA,GAAkBJ,WAAW,CAACI,OAAD,CAA7BA,GAAyCrL,SAAhD;AAVG;AAYL8J,WAAO,EAAE,iBAACpF,GAAD,EAAMmG,IAAN;AAAA,aAAeP,OAAO,CAACR,OAARQ,CAAgB5F,GAAhB4F,EAAqBM,SAAS,CAACC,IAAD,CAA9BP,CAAf;AAZJ;AAaLP,cAAU,EAAE,oBAACrF,GAAD;AAAA,aAAS4F,OAAO,CAACP,UAARO,CAAmB5F,GAAnB4F,CAAT;AAAA;AAbP,GAAP;AAeD;;AAEM,SAASgB,oBAAT,CAA8BtG,IAA9B,EAAoCuG,UAApC,EAAqD;AAAA,MAAjBA,UAAiB;AAAjBA,cAAiB,GAAJ,EAAbA;AAAiB;;AAC1D,SAAO;AACLvG,QAAI,EAAJA,IADK;AAELvB,UAAM,EAAE;AACN+H,WAAK,EAAED,UAAU,CAACC,KAAXD,IAAoB,EADrB;AAENE,UAAI,EAAEF,UAAU,CAACE,IAAXF,IAAmB,EAFnB;AAGNG,mBAAa,EAAEH,UAAU,CAACG,aAAXH,IAA4B,WAHrC;AAINjB,aAAO,EAAED,oBAAoB,CAC3BkB,UAAU,CAACjB,OADgB,EAE3BiB,UAAU,CAAChB,YAFgB;AAJvB;AAFH,GAAP;AAYD;;AAED,SAASoB,qBAAT,CAA+B1G,MAA/B,EAAuCuG,KAAvC,EAA8CC,IAA9C,EAAoD;AAClD,MAAIG,OAAO,GAAG3H,MAAM,CAACM,IAAPN,CAAYgB,MAAZhB,CAAd;;AACA,MAAIuH,KAAK,CAACjG,MAANiG,GAAe,CAAnB,EAAsB;AACpBI,WAAO,GAAGA,OAAO,CAACpH,MAARoH,CAAe,UAACnH,GAAD,EAAMS,GAAN,EAAc;AACrC,UAAIsG,KAAK,CAACK,SAANL,CAAgB,UAACzG,CAAD;AAAA,eAAOA,CAAC,KAAKG,GAAb;AAAhB,aAAsC,CAAC,CAA3C,EAA8C;AAC5C,yBAAWT,GAAX,GAAgBS,GAAhB;AACD;;AACD,aAAOT,GAAP;AAJQ,OAKP,EALOmH,CAAVA;AAMD;;AACD,MAAIH,IAAI,CAAClG,MAALkG,GAAc,CAAlB,EAAqB;AACnBG,WAAO,GAAGA,OAAO,CAACpH,MAARoH,CAAe,UAACnH,GAAD,EAAMS,GAAN,EAAc;AACrC,UAAIuG,IAAI,CAACI,SAALJ,CAAe,UAAC1G,CAAD;AAAA,eAAOA,CAAC,KAAKG,GAAb;AAAf,aAAqC,CAAC,CAA1C,EAA6C;AAC3C,eAAOT,GAAP;AACD;;AACD,uBAAWA,GAAX,GAAgBS,GAAhB;AAJQ,OAKP,EALO0G,CAAVA;AAMD;;AACD,SAAOA,OAAP;AACD;;AAED,SAASE,wBAAT,CAAkCC,UAAlC,EAA8CC,EAA9C,EAAkD;AAChD,SAAO,YAAM;AACX,QAAIA,EAAE,CAACC,EAAHD,CAAME,kBAANF,CAAyBzG,MAAzByG,KAAoC,CAAxC,EAA2C;AACzC,aAAOnF,OAAO,CAACC,OAARD,EAAP;AACD;;AACD,WAAOW,OAAO,CACZwE,EAAE,CAACC,EAAHD,CAAME,kBAANF,CAAyBG,GAAzBH,CAA6B;AAAA,UAAGhH,IAAH,QAAGA,IAAH;AAAA,UAASvB,MAAT,QAASA,MAAT;AAAA,aAAsB;AAAA,eACjDoD,OAAO,CAACC,OAARD,CAAgBpD,MAAM,CAAC6G,OAAP7G,CAAesG,UAAftG,CAA0BsI,UAAU,CAAC/G,IAAD,CAApCvB,CAAhBoD,CADiD;AAAtB;AAA7B,MADY,CAAd;AAJF;AAUD;;AAEM,SAASuF,eAAT,CAAyBL,UAAzB,EAAqCC,EAArC,EAAyC;AAC9C,MAAIK,cAAc,GAAGxF,OAAO,CAACC,OAARD,EAArB;AACA,MAAIyF,YAAY,GAAG,KAAnB;AACA,MAAIC,oBAAJ;AAEA,MAAMC,YAAY,GAChB,OAAO3N,MAAP,KAAkB,WAAlB,GACI,UAACiE,EAAD;AAAA,WAAQA,EAAE,EAAV;AADJ,MAEIjE,MAAM,CAAC4N,mBAAP5N,IAA8B,IAA9BA,GACAA,MAAM,CAAC4N,mBADP5N,GAEAA,MAAM,CAAC6N,qBALb;;AAOA,MAAM7K,OAAO,GAAG,SAAVA,OAAU,CAAC8K,SAAD,EAAe;AAC7B,QAAIX,EAAE,CAACC,EAAHD,CAAME,kBAANF,CAAyBzG,MAAzByG,KAAoC,CAAxC,EAA2C;AACzC;AACD;;AAED,QAAMY,SAAS,GAAG,SAAZA,SAAY,GAAM;AACtBN,kBAAY,GAAG,IAAfA;AACAD,oBAAc,GAAG,IAAIxF,OAAJ,CAAY,UAACC,OAAD,EAAa;AACxC0F,oBAAY,CAAC,YAAM;AACjBhF,iBAAO,CACLwE,EAAE,CAACC,EAAHD,CAAME,kBAANF,CAAyBG,GAAzBH,CAA6B;AAAA,gBAAGhH,IAAH,SAAGA,IAAH;AAAA,gBAASvB,MAAT,SAASA,MAAT;AAAA,mBAAsB,YAAM;AACvD,kBAAQ6G,OAAR,GAAiC7G,MAAjC,CAAQ6G,OAAR;AAAA,kBAAiBkB,KAAjB,GAAiC/H,MAAjC,CAAiB+H,KAAjB;AAAA,kBAAwBC,IAAxB,GAAiChI,MAAjC,CAAwBgI,IAAxB;AACA,kBAAMoB,gBAAgB,GAAG1I,KAAK,CAACS,GAAG,CAACI,IAAD,EAAO2H,SAAP,CAAJ,CAA9B;AACA,kBAAMG,cAAc,GAAGnB,qBAAqB,CAC1CkB,gBAD0C,EAE1CrB,KAF0C,EAG1CC,IAH0C,CAA5C;AAKA,kBAAMsB,cAAc,GAAG,EAAvB;AACAD,4BAAc,CAACX,GAAfW,CAAmB,UAACpI,GAAD,EAAS;AAC1B,oBAAMsI,UAAU,aAAOhI,IAAP,GAAaN,GAAb,EAAhB;AACA,oBAAMuI,QAAQ,GAAGrI,GAAG,CAACoI,UAAD,EAAaL,SAAb,CAApB;AACA,oBAAMpJ,KAAK,GAAGO,aAAa,CAACmJ,QAAD,CAAbnJ,GACVK,KAAK,CAAC8I,QAAD,CADKnJ,GAEVmJ,QAFJ;AAGAF,8BAAc,CAACrI,GAAD,CAAdqI,GAAsBxJ,KAAtBwJ;AANF;AAQA,qBAAOlG,OAAO,CAACC,OAARD,CACLyD,OAAO,CAACR,OAARQ,CAAgByB,UAAU,CAAC/G,IAAD,CAA1BsF,EAAkCyC,cAAlCzC,CADKzD,CAAP;AAjB2B;AAA7B,YADK,CAAPW,CAsBE0F,OAtBF1F,CAsBU,YAAM;AACd8E,wBAAY,GAAG,KAAfA;;AACA,gBAAIC,oBAAJ,EAA0B;AACxB,kBAAMjI,IAAI,GAAGiI,oBAAb;AACAA,kCAAoB,GAAG,IAAvBA;AACAjI,kBAAI;AAHN,mBAIO;AACLwC,qBAAO;AACR;AA9BH;AADU,UAAZ0F;AADe,QAAjBH;AAFF;;AAwCA,QAAIC,YAAJ,EAAkB;AAChBC,0BAAoB,GAAGK,SAAvBL;AADF,WAEO;AACLK,eAAS;AACV;AAjDH;;AAoDA,SAAO;AACL/K,WAAO,EAAPA,OADK;AAELsL,SAAK,EAAErB,wBAAwB,CAACC,UAAD,EAAaC,EAAb,CAF1B;AAGLoB,SAAK,EAAE,iBAAM;AACX,UAAIb,oBAAJ,EAA0B;AACxBA,4BAAoB;AACrB;;AACD,aAAOF,cAAP;AACD;AARI,GAAP;AAUD;;AAEM,SAASgB,uBAAT,CAAiCC,SAAjC,EAA4CtB,EAA5C,EAAgD;AACrD,SAAO;AAAA,QAAG/L,QAAH,SAAGA,QAAH;AAAA,WAAkB,UAACqE,IAAD;AAAA,aAAU,UAACvB,MAAD,EAAY;AAC7C,YAAML,KAAK,GAAG4B,IAAI,CAACvB,MAAD,CAAlB;;AACA,YACEA,MAAM,IACNA,MAAM,CAACoG,IAAPpG,KAAgB,cADhBA,IAEAiJ,EAAE,CAACC,EAAHD,CAAME,kBAANF,CAAyBzG,MAAzByG,GAAkC,CAHpC,EAIE;AACAsB,mBAAS,CAACzL,OAAVyL,CAAkBrN,QAAQ,EAA1BqN;AACD;;AACD,eAAO5K,KAAP;AATuB;AAAlB;AAAP;AAWD;;AAEM,SAAS6K,iCAAT,CACLxB,UADK,EAELyB,YAFK,EAGLxB,EAHK,EAILyB,IAJK,EAKL;AACA,MAAIzB,EAAE,CAACC,EAAHD,CAAME,kBAANF,CAAyBzG,MAAzByG,KAAoC,CAAxC,EAA2C;AACzC,WAAOnF,OAAO,CAACC,OAARD,EAAP;AACD;;AAED,MAAMnE,KAAK,GAAGyB,KAAK,CAAC6H,EAAE,CAACC,EAAHD,CAAM0B,GAAP,CAAnB;AAEA,MAAIC,WAAW,GAAG,KAAlB;AAEA,SAAOnG,OAAO,CACZwE,EAAE,CAACC,EAAHD,CAAME,kBAANF,CAAyBG,GAAzBH,CAA6B,UAAC4B,eAAD;AAAA,WAAqB,YAAM;AACtD,UAAQ5I,IAAR,GAAyB4I,eAAzB,CAAQ5I,IAAR;AAAA,UAAcvB,MAAd,GAAyBmK,eAAzB,CAAcnK,MAAd;AACA,UAAQiI,aAAR,GAAmCjI,MAAnC,CAAQiI,aAAR;AAAA,UAAuBpB,OAAvB,GAAmC7G,MAAnC,CAAuB6G,OAAvB;;AAEA,UAAImD,IAAI,KAAKzI,IAAI,CAACO,MAALP,GAAc,CAAdA,IAAmBA,IAAI,CAAC,CAAD,CAAJA,KAAYyI,IAApC,CAAR,EAAmD;AACjD,eAAO5G,OAAO,CAACC,OAARD,EAAP;AACD;;AAED,UAAMgH,mBAAmB,GAAG,SAAtBA,mBAAsB,CAACC,SAAD,EAAYC,oBAAZ;AAAA,eAC1BD,SAAS,IAAI,IAAbA,IACAC,oBAAoB,IAAI,IADxBD,KAEC,OAAOA,SAAP,KAAqB,OAAOC,oBAA5B,IACEC,KAAK,CAACC,OAAND,CAAcF,SAAdE,KAA4B,CAACA,KAAK,CAACC,OAAND,CAAcD,oBAAdC,CAHhCF,CAD0B;AAA5B;;AAMA,UAAMI,wBAAwB,GAAG,SAA3BA,wBAA2B,CAACC,cAAD,EAAoB;AACnD,YAAIzC,aAAa,KAAK,WAAtB,EAAmC;AACjCjG,aAAG,CAACT,IAAD,EAAOtC,KAAP,EAAcyL,cAAd,CAAH1I;AADF,eAEO,IAAIiG,aAAa,KAAK,cAAtB,EAAsC;AAC3C,cAAM0C,WAAW,GAAGxJ,GAAG,CAACI,IAAD,EAAOtC,KAAP,CAAvB;AACAuB,gBAAM,CAACM,IAAPN,CAAYkK,cAAZlK,EAA4BY,OAA5BZ,CAAoC,UAACS,GAAD,EAAS;AAC3C,gBAAImJ,mBAAmB,CAACO,WAAW,CAAC1J,GAAD,CAAZ,EAAmByJ,cAAc,CAACzJ,GAAD,CAAjC,CAAvB,EAAgE,CAAhE,KAEO;AACL0J,yBAAW,CAAC1J,GAAD,CAAX0J,GAAmBD,cAAc,CAACzJ,GAAD,CAAjC0J;AACD;AALH;AAFK,eASA,IAAI1C,aAAa,KAAK,WAAtB,EAAmC;AACxC,cAAM0C,YAAW,GAAGxJ,GAAG,CAACI,IAAD,EAAOtC,KAAP,CAAvB;;AACA,cAAM2L,KAAK,GAAG,SAARA,KAAQ,CAACC,kBAAD,EAAqBC,qBAArB,EAA+C;AAC3DtK,kBAAM,CAACM,IAAPN,CAAYsK,qBAAZtK,EAAmCY,OAAnCZ,CAA2C,UAACS,GAAD,EAAS;AAClD,kBACEmJ,mBAAmB,CACjBS,kBAAkB,CAAC5J,GAAD,CADD,EAEjB6J,qBAAqB,CAAC7J,GAAD,CAFJ,CADrB,EAKE,CALF,KAOO,IAAIZ,aAAa,CAACyK,qBAAqB,CAAC7J,GAAD,CAAtB,CAAjB,EAA+C;AACpD4J,kCAAkB,CAAC5J,GAAD,CAAlB4J,GAA0BA,kBAAkB,CAAC5J,GAAD,CAAlB4J,IAA2B,EAArDA;AACAD,qBAAK,CAACC,kBAAkB,CAAC5J,GAAD,CAAnB,EAA0B6J,qBAAqB,CAAC7J,GAAD,CAA/C,CAAL2J;AAFK,qBAGA;AACLC,kCAAkB,CAAC5J,GAAD,CAAlB4J,GAA0BC,qBAAqB,CAAC7J,GAAD,CAA/C4J;AACD;AAbH;AADF;;AAiBAD,eAAK,CAACD,YAAD,EAAcD,cAAd,CAALE;AACD;AAhCH;;AAmCA,UAAMG,QAAQ,GAAG,SAAXA,QAAW,CAACL,cAAD,EAAoB;AACnC,YAAIA,cAAc,IAAI,IAAtB,EAA4B;AAC1BD,kCAAwB,CAACC,cAAD,CAAxBD;AACAP,qBAAW,GAAG,IAAdA;AACD;AAJH;;AAOA,UAAMc,aAAa,GAAGnE,OAAO,CAACT,OAARS,CAAgByB,UAAU,CAAC/G,IAAD,CAA1BsF,CAAtB;;AACA,UAAIxF,SAAS,CAAC2J,aAAD,CAAb,EAA8B;AAC5B,eAAOA,aAAa,CAAC1M,IAAd0M,CAAmBD,QAAnBC,CAAP;AACD;;AACD,aAAO5H,OAAO,CAACC,OAARD,CAAgB2H,QAAQ,CAACC,aAAD,CAAxB5H,CAAP;AA5D2B;AAA7B,IADY,CAAPW,CA+DLzF,IA/DKyF,CA+DA,YAAM;AACX,QAAImG,WAAJ,EAAiB;AACfH,kBAAY,CAAC9K,KAAD,CAAZ8K;AACD;AAlEI,IAAP;AAoED;;ACvUM,SAASkB,mBAAT,CAA6BtF,GAA7B,EAAkC4C,EAAlC,EAAsC;AAC3C,WAAS2C,aAAT,CAAuB1F,OAAvB,EAAgC;AAC9B,QAAMlG,MAAM,GAAG;AACboG,UAAI,EAAEC,GAAG,CAACC,IAAJD,CAASD,IADF;AAEbF,aAAO,EAAPA;AAFa,KAAf;;AAIA,QAAIG,GAAG,CAAClH,cAAD,CAAHkH,IAAuBA,GAAG,CAACC,IAAJD,CAASwF,eAApC,EAAqD;AACnD3F,aAAO,CAAC2F,eAAR3F,aAA8BG,GAAG,CAACC,IAAJD,CAASwF,eAAvC;AACD;;AACD,WAAO5C,EAAE,CAAC1K,QAAH0K,CAAYjJ,MAAZiJ,CAAP;AATyC;;;AAa3C2C,eAAa,CAACxF,IAAdwF,GAAqBvF,GAAG,CAACC,IAAJD,CAASD,IAA9BwF;AAEA,SAAOA,aAAP;AACD;;ACfM,SAASE,kBAAT,CAA4BzF,GAA5B,EAAiC4C,EAAjC,EAAqC8C,UAArC,EAAiDC,GAAjD,EAAsD;AAC3D,SAAO,UAAC9F,OAAD,EAAU+F,IAAV,EAAmB;AACxB,QAAMC,OAAO,GAAG;AACd3N,cAAQ,EAAE0K,EAAE,CAAC1K,QADC;AAEd0N,UAAI,EAAJA,IAFc;AAGd/O,cAAQ,EAAE;AAAA,eAAM2E,GAAG,CAACwE,GAAG,CAACC,IAAJD,CAAS3C,MAAV,EAAkBuF,EAAE,CAAC/L,QAAH+L,EAAlB,CAAT;AAHI;AAIdkD,qBAAe,EAAE;AAAA,eAAMH,GAAN;AAJH;AAKdI,mBAAa,EAAEnD,EAAE,CAAC/L,QALJ;AAMd6O,gBAAU,EAAVA,UANc;AAOdzF,UAAI,EAAE;AACJ3E,WAAG,EAAE0E,GAAG,CAACC,IAAJD,CAASgG,UADV;AAEJ3I,cAAM,EAAE2C,GAAG,CAACC,IAAJD,CAAS3C,MAFb;AAGJzB,YAAI,EAAEoE,GAAG,CAACC,IAAJD,CAASpE;AAHX;AAPQ,KAAhB;;AAaA,QAAIoE,GAAG,CAAC7G,aAAD,CAAH6G,IAAsBA,GAAG,CAACC,IAAJD,CAASwF,eAAnC,EAAoD;AAClD3F,aAAO,CAAC2F,eAAR3F,aAA8BG,GAAG,CAACC,IAAJD,CAASwF,eAAvC;AACD;;AACD,WAAOxF,GAAG,CAACtG,EAAJsG,CAAOxE,GAAG,CAACwE,GAAG,CAACC,IAAJD,CAAS3C,MAAV,EAAkBsI,GAAlB,CAAV3F,EAAkCH,OAAlCG,EAA2C6F,OAA3C7F,CAAP;AAjBF;AAmBD;;AAED,IAAMiG,0BAA0B,GAAG,SAA7BA,0BAA6B,CAAClG,IAAD,EAAOjJ,GAAP,EAAe;AAChD;AACAsK,SAAO,CAAC8E,GAAR9E,eAAwBrB,IAAxBqB,EAFgD;;AAIhDA,SAAO,CAAC8E,GAAR9E,CAAYtK,GAAZsK;AAJF;;AAOA,IAAM+E,2BAAyB,GAAG,SAA5BA,yBAA4B,CAACpG,IAAD,EAAOqG,UAAP;AAAA,SAAsB,YAAa;AACnE,QAAI;AACF,UAAMlJ,MAAM,GAAGkJ,UAAU,MAAVA,mBAAf;;AACA,UAAI1K,SAAS,CAACwB,MAAD,CAAb,EAAuB;AACrBA,cAAM,CAACiB,KAAPjB,CAAa,UAACpG,GAAD,EAAS;AACpBmP,oCAA0B,CAAClG,IAAD,EAAOjJ,GAAP,CAA1BmP;AADF;AAGD;AANH,MAOE,OAAOnP,GAAP,EAAY;AACZmP,gCAA0B,CAAClG,IAAD,EAAOjJ,GAAP,CAA1BmP;AACD;AAV+B;AAAlC;;AAaO,SAASI,yBAAT,CAAmCrG,GAAnC,EAAwC4C,EAAxC,EAA4C;AACjD,MAAM2C,aAAa,GAAG,SAAhBA,aAAgB,CAAC1F,OAAD,EAAa;AACjC,QAAMyG,aAAa,GAAGH,2BAAyB,CAACnG,GAAG,CAACC,IAAJD,CAASuG,SAAV,EAAqB;AAAA,aAClE3D,EAAE,CAAC1K,QAAH0K,CAAY;AACV7C,YAAI,EAAEC,GAAG,CAACC,IAAJD,CAASuG,SADL;AAEV1G,eAAO,EAAPA;AAFU,OAAZ+C,CADkE;AAArB,MAA/C;AAOA,QAAM4D,YAAY,GAAGL,2BAAyB,CAACnG,GAAG,CAACC,IAAJD,CAASyG,QAAV,EAAoB,UAAC3P,GAAD;AAAA,aAChE8L,EAAE,CAAC1K,QAAH0K,CAAY;AACV7C,YAAI,EAAEC,GAAG,CAACC,IAAJD,CAASyG,QADL;AAEV5G,eAAO,EAAPA,OAFU;AAGV6G,aAAK,EAAE5P;AAHG,OAAZ8L,CADgE;AAApB,MAA9C;AAQA,QAAM+D,eAAe,GAAGR,2BAAyB,CAC/CnG,GAAG,CAACC,IAAJD,CAAS4G,WADsC,EAE/C,UAAC1J,MAAD;AAAA,aACE0F,EAAE,CAAC1K,QAAH0K,CAAY;AACV7C,YAAI,EAAEC,GAAG,CAACC,IAAJD,CAAS4G,WADL;AAEV/G,eAAO,EAAPA,OAFU;AAGV3C,cAAM,EAANA;AAHU,OAAZ0F,CADF;AAF+C,MAAjD;AAUA0D,iBAAa;AAEb,QAAIO,OAAO,GAAG,IAAd;;AAEA,QAAMjB,IAAI,GAAG,SAAPA,IAAO,CAACkB,QAAD,EAAc;AACzBD,aAAO,GAAGC,QAAVD;AADF;;AAIA,QAAM3J,MAAM,GAAG0F,EAAE,CAAC1K,QAAH0K,CAAY;AAAA,aAAM5C,GAAG,CAAC+G,YAAJ/G,CAAiBH,OAAjBG,EAA0B4F,IAA1B5F,CAAN;AAAZ,MAAf;;AAEA,QAAItE,SAAS,CAACwB,MAAD,CAAb,EAAuB;AACrB,aAAOA,MAAM,CAACvE,IAAPuE,CAAY,UAAC8J,QAAD,EAAc;AAC/B,YAAIH,OAAJ,EAAa;AACXL,sBAAY,CAACK,OAAD,CAAZL;AADF,eAEO;AACLG,yBAAe,CAACK,QAAD,CAAfL;AACD;;AACD,eAAOK,QAAP;AANK,QAAP;AAQD;;AAED,QAAIH,OAAJ,EAAa;AACXL,kBAAY,CAACK,OAAD,CAAZL;AADF,WAEO;AACLG,qBAAe,CAACzJ,MAAD,CAAfyJ;AACD;;AAED,WAAOzJ,MAAP;AArDF;;AAwDAqI,eAAa,CAACxF,IAAdwF,GAAqBvF,GAAG,CAACC,IAAJD,CAASD,IAA9BwF;AACAA,eAAa,CAACqB,WAAdrB,GAA4BvF,GAAG,CAACC,IAAJD,CAAS4G,WAArCrB;AACAA,eAAa,CAACkB,QAAdlB,GAAyBvF,GAAG,CAACC,IAAJD,CAASyG,QAAlClB;AACAA,eAAa,CAACgB,SAAdhB,GAA0BvF,GAAG,CAACC,IAAJD,CAASuG,SAAnChB;AAEA,SAAOA,aAAP;AACD;;AC1GM,SAAS0B,wBAAT,CAAkCrE,EAAlC,EAAsC;AAC3C,SAAO;AAAA,WAAM,UAAC1H,IAAD;AAAA,aAAU,UAACvB,MAAD,EAAY;AACjC,YAAMuD,MAAM,GAAGhC,IAAI,CAACvB,MAAD,CAAnB;;AACA,YACEA,MAAM,IACNiJ,EAAE,CAACC,EAAHD,CAAMsE,IAANtE,CAAWjJ,MAAM,CAACoG,IAAlB6C,CADAjJ,IAEAiJ,EAAE,CAACC,EAAHD,CAAMsE,IAANtE,CAAWjJ,MAAM,CAACoG,IAAlB6C,EAAwBzG,MAAxByG,GAAiC,CAHnC,EAIE;AACA,cAAMuE,YAAY,GAAGvE,EAAE,CAACC,EAAHD,CAAMwE,IAANxE,CAAWjJ,MAAM,CAACoG,IAAlB6C,CAArB;;AACAA,YAAE,CAACC,EAAHD,CAAMsE,IAANtE,CAAWjJ,MAAM,CAACoG,IAAlB6C,EAAwBnH,OAAxBmH,CAAgC,UAAC2C,aAAD,EAAmB;AACjDA,yBAAa,CAAC;AACZxF,kBAAI,EAAEoH,YAAY,GAAGA,YAAY,CAACnH,GAAbmH,CAAiBlH,IAAjBkH,CAAsBpH,IAAzB,GAAgCpG,MAAM,CAACoG,IAD7C;AAEZF,qBAAO,EAAElG,MAAM,CAACkG,OAFJ;AAGZ6G,mBAAK,EAAE/M,MAAM,CAAC+M,KAHF;AAIZxJ,oBAAM,EAAEvD,MAAM,CAACuD;AAJH,aAAD,CAAbqI;AADF;AAQD;;AACD,eAAOrI,MAAP;AAjBW;AAAN;AAAP;AAmBD;;AAEM,SAASmK,gBAAT,CAA0BC,YAA1B,EAAwC3B,GAAxC,EAA6CyB,IAA7C,EAAmDF,IAAnD,EAAyD;AAC9DI,cAAY,CAAC7L,OAAb6L,CAAqB,UAACtH,GAAD,EAAS;AAC5B,QAAMwC,OAAO,GAAGxC,GAAG,CAACvG,cAAJuG,CAAmBxE,GAAG,CAACwE,GAAG,CAACC,IAAJD,CAAS3C,MAAV,EAAkBsI,GAAlB,CAAtB3F,EAA8C2F,GAA9C3F,CAAhB;AAEA,QAAMuH,WAAW,GAAG,CAAC3C,KAAK,CAACC,OAAND,CAAcpC,OAAdoC,IAAyBpC,OAAzBoC,GAAmC,CAACpC,OAAD,CAApC,EAA+CpH,MAA/C,CAClB,UAACC,GAAD,EAAMQ,MAAN,EAAiB;AACf,UACE,OAAOA,MAAP,KAAkB,UAAlB,IACAA,MAAM,CAACmE,GAAPnE,CAAWoE,IAAXpE,CAAgBkE,IADhB,IAEAqH,IAAI,CAACvL,MAAM,CAACmE,GAAPnE,CAAWoE,IAAXpE,CAAgBkE,IAAjB,CAHN,EAIE;AACA,YAAIlE,MAAM,CAACmE,GAAPnE,CAAWoE,IAAXpE,CAAgB+K,WAApB,EAAiC;AAC/BvL,aAAG,CAACoD,IAAJpD,CAASQ,MAAM,CAACmE,GAAPnE,CAAWoE,IAAXpE,CAAgB+K,WAAzBvL;AADF,eAEO;AACLA,aAAG,CAACoD,IAAJpD,CAASQ,MAAM,CAACmE,GAAPnE,CAAWoE,IAAXpE,CAAgBkE,IAAzB1E;AACD;AATH,aAUO,IAAI,OAAOQ,MAAP,KAAkB,QAAtB,EAAgC;AACrCR,WAAG,CAACoD,IAAJpD,CAASQ,MAATR;AACD;;AACD,aAAOA,GAAP;AAfgB,OAiBlB,EAjBkB,CAApB;AAoBA2E,OAAG,CAACC,IAAJD,CAASwF,eAATxF,GAA2BuH,WAA3BvH;AAEAuH,eAAW,CAAC9L,OAAZ8L,CAAoB,UAACC,UAAD,EAAgB;AAClC,UAAMC,WAAW,GAAGP,IAAI,CAACM,UAAD,CAAJN,IAAoB,EAAxC;AACAO,iBAAW,CAAChJ,IAAZgJ,CAAiBL,IAAI,CAACpH,GAAG,CAACC,IAAJD,CAASD,IAAV,CAArB0H;AACAP,UAAI,CAACM,UAAD,CAAJN,GAAmBO,WAAnBP;AAHF;AAzBF;AA+BD;;ACtDM,SAASQ,4BAAT,CAAsCtK,UAAtC,EAAkD9B,GAAlD,EAAuD0E,GAAvD,EAA4D4C,EAA5D,EAAgE;AACrE,MAAI+E,OAAO,GAAG,KAAd;AACA,MAAIC,UAAU,GAAG,EAAjB;AACA,MAAIC,SAAJ;AACA,SAAO,SAASC,sBAAT,CAAgCvH,WAAhC,EAA6CwH,UAA7C,EAAyD;AAC9DlN,UAAM,CAACmN,cAAPnN,CAAsB0F,WAAtB1F,EAAmCS,GAAnCT,EAAwC;AACtCoN,kBAAY,EAAE,IADwB;AAEtCC,gBAAU,EAAE,IAF0B;AAGtC1M,SAAG,EAAE,eAAM;AACT,YAAMwD,MAAM,GAAGgB,GAAG,CAACjG,cAAJiG,CAAmB+C,GAAnB/C,CAAuB,UAACmI,QAAD;AAAA,iBACpCA,QAAQ,CAAC5H,WAAD,EAAcwH,UAAd,CAD4B;AAAvB,UAAf;;AAGA,YACEJ,OAAO,KACNjJ,cAAc,CAACkJ,UAAD,EAAa5I,MAAb,CAAdN,IACEkE,EAAE,CAACC,EAAHD,CAAMwF,GAANxF,CAAUyF,WAAVzF,IACC,IAAIvL,KAAJ,GAAYD,KAAZ,CAAkBkR,KAAlB,CAAwB,eAAxB,MAA6C,IAH1C,CADT,EAKE;AACA;AACA;AACA;AACA,iBAAOT,SAAP;AACD;;AACDD,kBAAU,GAAG5I,MAAb4I;AACAC,iBAAS,GAAG7H,GAAG,CAACtG,EAAJsG,YAAUhB,MAAVgB,CAAZ6H;AACAF,eAAO,GAAG,IAAVA;AACA,eAAOE,SAAP;AACD;AAtBqC,KAAxChN;AADF;AA0BD;;AAEM,SAAS0N,kCAAT,CAA4C3F,EAA5C,EAAgD;AACrD,SAAO;AAAA,WAAM,UAAC1H,IAAD;AAAA,aAAU,UAACvB,MAAD,EAAY;AACjCiJ,UAAE,CAACC,EAAHD,CAAMwF,GAANxF,CAAUyF,WAAVzF,GAAwB,IAAxBA;AACA,YAAM1F,MAAM,GAAGhC,IAAI,CAACvB,MAAD,CAAnB;AACAiJ,UAAE,CAACC,EAAHD,CAAMwF,GAANxF,CAAUyF,WAAVzF,GAAwB,KAAxBA;AACA,eAAO1F,MAAP;AAJW;AAAN;AAAP;AAMD;;ACvCM,SAASsL,uBAAT,CAAiC5F,EAAjC,EAAqC;AAC1C,SAAO,UAAC3M,KAAD;AAAA,WAAW,UAACiF,IAAD;AAAA,aAAU,UAACvB,MAAD,EAAY;AACtC,YAAIiJ,EAAE,CAACC,EAAHD,CAAM6F,EAAN7F,CAASzG,MAATyG,KAAoB,CAAxB,EAA2B;AACzB,iBAAO1H,IAAI,CAACvB,MAAD,CAAX;AACD;;AACD,YAAM+O,SAAS,GAAGzS,KAAK,CAACY,QAANZ,EAAlB;AACA,YAAMiH,MAAM,GAAGhC,IAAI,CAACvB,MAAD,CAAnB;AACA,YAAM4J,SAAS,GAAGtN,KAAK,CAACY,QAANZ,EAAlB;;AACA2M,UAAE,CAACC,EAAHD,CAAM6F,EAAN7F,CAASnH,OAATmH,CAAiB,UAAC5C,GAAD,EAAS;AACxB,cAAM2I,SAAS,GAAGnN,GAAG,CAACwE,GAAG,CAACC,IAAJD,CAAS3C,MAAV,EAAkBqL,SAAlB,CAArB;AACA,cAAME,SAAS,GAAGpN,GAAG,CAACwE,GAAG,CAACC,IAAJD,CAAS3C,MAAV,EAAkBkG,SAAlB,CAArB;;AACA,cAAIoF,SAAS,KAAKC,SAAlB,EAA6B;AAC3B,gBAAMC,gBAAgB,GAAG7I,GAAG,CAAC/F,mBAAJ+F,CAAwB+C,GAAxB/C,CAA4B,UAACmI,QAAD;AAAA,qBACnDA,QAAQ,CAACQ,SAAD,CAD2C;AAA5B,cAAzB;AAGA,gBAAMG,gBAAgB,GAAG9I,GAAG,CAAC/F,mBAAJ+F,CAAwB+C,GAAxB/C,CAA4B,UAACmI,QAAD;AAAA,qBACnDA,QAAQ,CAACS,SAAD,CAD2C;AAA5B,cAAzB;AAGA,gBAAMG,UAAU,GAAGF,gBAAgB,CAACG,IAAjBH,CACjB,UAACI,UAAD,EAAa3M,GAAb;AAAA,qBAAqB2M,UAAU,KAAKH,gBAAgB,CAACxM,GAAD,CAApD;AADiB,cAAnB;;AAGA,gBAAIyM,UAAJ,EAAgB;AACd/I,iBAAG,CAACuF,aAAJvF,CAAkB6I,gBAAlB7I,EAAoC8I,gBAApC9I,EAAsDrG,MAAtDqG;AACD;AACF;AAhBH;;AAkBA,eAAO9C,MAAP;AAzBgB;AAAX;AAAP;AA2BD;;AAED,IAAMgM,cAAc,GAAG,SAAjBA,cAAiB,CAACpS,GAAD,EAAS;AAC9B;AACA;AACAsK,SAAO,CAAC8E,GAAR9E,CAAYtK,GAAZsK;AAHF;;AAMO,SAAS+H,mBAAT,CAA6BnJ,GAA7B,EAAkC4C,EAAlC,EAAsC8C,UAAtC,EAAkDC,GAAlD,EAAuD;AAC5D,MAAMyD,OAAO,GAAG5N,GAAG,CAACwE,GAAG,CAACC,IAAJD,CAAS3C,MAAV,EAAkBsI,GAAlB,CAAnB;AAEA,MAAI0D,OAAJ;AAEA,SAAO,UAACC,MAAD,EAAY;AACjB,QAAMzD,OAAO,GAAG;AACd3N,cAAQ,EAAE0K,EAAE,CAAC1K,QADC;AAEdrB,cAAQ,EAAE;AAAA,eAAM2E,GAAG,CAACwE,GAAG,CAACC,IAAJD,CAAS3C,MAAV,EAAkBuF,EAAE,CAAC/L,QAAH+L,EAAlB,CAAT;AAFI;AAGdkD,qBAAe,EAAE;AAAA,eAAMH,GAAN;AAHH;AAIdI,mBAAa,EAAEnD,EAAE,CAAC/L,QAJJ;AAKd6O,gBAAU,EAAVA,UALc;AAMdzF,UAAI,EAAE;AACJ3E,WAAG,EAAE0E,GAAG,CAACC,IAAJD,CAASgG,UADV;AAEJ3I,cAAM,EAAE2C,GAAG,CAACC,IAAJD,CAAS3C,MAFb;AAGJzB,YAAI,EAAEoE,GAAG,CAACC,IAAJD,CAASpE;AAHX;AANQ,KAAhB;;AAaA,QAAIyN,OAAO,KAAKzS,SAAhB,EAA2B;AACzB,UAAM2S,aAAa,GAAGF,OAAO,EAA7B;AACAA,aAAO,GAAGzS,SAAVyS;;AACA,UAAI3N,SAAS,CAAC6N,aAAD,CAAb,EAA8B;AAC5BA,qBAAa,CAACpL,KAAdoL,CAAoBL,cAApBK;AACD;AACF;;AAED,QAAMC,YAAY,GAAGxJ,GAAG,CAACtG,EAAJsG,CAAOoJ,OAAPpJ,EAAgBsJ,MAAhBtJ,EAAwB6F,OAAxB7F,CAArB;;AAEA,QAAItE,SAAS,CAAC8N,YAAD,CAAb,EAA6B;AAC3B,aAAOA,YAAY,CAAC7Q,IAAb6Q,CAAkB,UAACxC,QAAD,EAAc;AACrC,YAAI,OAAOA,QAAP,KAAoB,UAAxB,EAAoC;AAClC,cAAIjQ,OAAO,CAACC,GAARD,CAAYE,QAAZF,KAAyB,YAA7B,EAA2C;AACzC;AACA;AACA;AACAqK,mBAAO,CAACC,IAARD,CACE,+DADFA;AAGD;AACF;AAVI,QAAP;AAYD;;AAED,QAAI,OAAOoI,YAAP,KAAwB,UAA5B,EAAwC;AACtCH,aAAO,GAAGG,YAAVH;AACD;;AAED,WAAOzS,SAAP;AA3CF;AA6CD;;AAED,IAAM6S,2BAA2B,GAAG,SAA9BA,2BAA8B,CAAC1J,IAAD,EAAOjJ,GAAP,EAAe;AACjD;AACAsK,SAAO,CAAC8E,GAAR9E,eAAwBrB,IAAxBqB,EAFiD;;AAIjDA,SAAO,CAAC8E,GAAR9E,CAAYtK,GAAZsK;AAJF;;AAOA,IAAM+E,yBAAyB,GAAG,SAA5BA,yBAA4B,CAACpG,IAAD,EAAOqG,UAAP;AAAA,SAAsB,YAAa;AACnE,QAAI;AACF,UAAMlJ,MAAM,GAAGkJ,UAAU,MAAVA,mBAAf;;AACA,UAAI1K,SAAS,CAACwB,MAAD,CAAb,EAAuB;AACrBA,cAAM,CAACiB,KAAPjB,CAAa,UAACpG,GAAD,EAAS;AACpB2S,qCAA2B,CAAC1J,IAAD,EAAOjJ,GAAP,CAA3B2S;AADF;AAGD;AANH,MAOE,OAAO3S,GAAP,EAAY;AACZ2S,iCAA2B,CAAC1J,IAAD,EAAOjJ,GAAP,CAA3B2S;AACD;AAV+B;AAAlC;;AAaO,SAASC,0BAAT,CAAoC1J,GAApC,EAAyC4C,EAAzC,EAA6C+G,aAA7C,EAA4D;AACjE,MAAMpE,aAAa,GAAG,SAAhBA,aAAgB,CAACqE,oBAAD,EAAuBd,gBAAvB,EAAyCnP,MAAzC,EAAoD;AACxE,QAAM2P,MAAM,GAAG;AACbO,UAAI,EAAED,oBADO;AAEbjT,aAAO,EAAEmS,gBAFI;AAGbnP,YAAM,EAANA;AAHa,KAAf;AAMA,QAAM2M,aAAa,GAAGH,yBAAyB,CAACnG,GAAG,CAACC,IAAJD,CAASuG,SAAV,EAAqB;AAAA,aAClE3D,EAAE,CAAC1K,QAAH0K,CAAY;AACV7C,YAAI,EAAEC,GAAG,CAACC,IAAJD,CAASuG,SADL;AAEV+C,cAAM,EAANA;AAFU,OAAZ1G,CADkE;AAArB,MAA/C;AAOA,QAAM+D,eAAe,GAAGR,yBAAyB,CAC/CnG,GAAG,CAACC,IAAJD,CAAS4G,WADsC,EAE/C;AAAA,aACEhE,EAAE,CAAC1K,QAAH0K,CAAY;AACV7C,YAAI,EAAEC,GAAG,CAACC,IAAJD,CAAS4G,WADL;AAEV0C,cAAM,EAANA;AAFU,OAAZ1G,CADF;AAF+C,MAAjD;AASA0D,iBAAa;;AAEb,QAAI;AACF,UAAMpJ,MAAM,GAAG0F,EAAE,CAAC1K,QAAH0K,CAAY;AAAA,eAAM+G,aAAa,CAACL,MAAD,CAAnB;AAAZ,QAAf;;AAEA,UAAI5N,SAAS,CAACwB,MAAD,CAAb,EAAuB;AACrB,eAAOA,MAAM,CAACvE,IAAPuE,CAAY,UAAC8J,QAAD,EAAc;AAC/BL,yBAAe,CAACK,QAAD,CAAfL;AACA,iBAAOK,QAAP;AAFK,WAGJkC,cAHIhM,CAAP;AAID;;AAEDyJ,qBAAe,CAACzJ,MAAD,CAAfyJ;AAEA,aAAOzJ,MAAP;AAZF,MAaE,OAAOpG,GAAP,EAAY;AACZoS,oBAAc,CAACpS,GAAD,CAAdoS;AACD;AAxCH;;AA2CA3D,eAAa,CAACxF,IAAdwF,GAAqBvF,GAAG,CAACC,IAAJD,CAASD,IAA9BwF;AACAA,eAAa,CAACgB,SAAdhB,GAA0BvF,GAAG,CAACC,IAAJD,CAASuG,SAAnChB;AACAA,eAAa,CAACqB,WAAdrB,GAA4BvF,GAAG,CAACC,IAAJD,CAAS4G,WAArCrB;AACAA,eAAa,CAACkB,QAAdlB,GAAyBvF,GAAG,CAACC,IAAJD,CAASyG,QAAlClB;AAEA,SAAOA,aAAP;AACD;;AC9Ic,SAASuE,oBAAT,CACb1P,KADa,EAEb2P,YAFa,EAGbrE,UAHa,EAIb9C,EAJa,EAKb;AACA,MAAM0B,GAAG,GAAGyF,YAAZ;AACA,MAAM3C,IAAI,GAAG,EAAb;AACA,MAAMzB,GAAG,GAAG,EAAZ;AACA,MAAMnG,IAAI,GAAG,EAAb;AACA,MAAMwK,YAAY,GAAG,EAArB;AACA,MAAMtK,GAAG,GAAG,EAAZ;AACA,MAAMD,GAAG,GAAG,EAAZ;AACA,MAAMgJ,EAAE,GAAG,EAAX;AACA,MAAMwB,IAAI,GAAG,EAAb;AACA,MAAM/C,IAAI,GAAG,EAAb;AACA,MAAMI,YAAY,GAAG,EAArB;AACA,MAAIxE,kBAAkB,GAAG,EAAzB;AACA,MAAMsF,GAAG,GAAG;AACVC,eAAW,EAAE;AADH,GAAZ;;AAIA,MAAM6B,yBAAyB,GAAG,SAA5BA,yBAA4B,CAACvT,OAAD,EAAUyG,UAAV;AAAA,WAChCvC,MAAM,CAACM,IAAPN,CAAYlE,OAAZkE,EAAqBY,OAArBZ,CAA6B,UAACS,GAAD,EAAS;AACpC,UAAMnB,KAAK,GAAGxD,OAAO,CAAC2E,GAAD,CAArB;AACA,UAAMM,IAAI,aAAOwB,UAAP,GAAmB9B,GAAnB,EAAV;AACA,UAAM2E,IAAI,GAAG;AACX5C,cAAM,EAAED,UADG;AAEXxB,YAAI,EAAJA,IAFW;AAGXN,WAAG,EAAHA;AAHW,OAAb;;AAKA,UAAM6O,kBAAkB,GAAG,SAArBA,kBAAqB,GAAM;AAC/B,YAAMC,gBAAgB,GAAG5O,GAAG,CAAC4B,UAAD,EAAa2M,YAAb,CAA5B;;AACA,YAAIK,gBAAgB,IAAI9O,GAAG,IAAI8O,gBAA/B,EAAiD;AAC/C/N,aAAG,CAACT,IAAD,EAAO0I,GAAP,EAAY8F,gBAAgB,CAAC9O,GAAD,CAA5B,CAAHe;AADF,eAEO;AACLA,aAAG,CAACT,IAAD,EAAO0I,GAAP,EAAYnK,KAAZ,CAAHkC;AACD;AANH;;AASA,UAAIf,GAAG,KAAKrC,aAAZ,EAA2B;AACzB6J,0BAAkB,CAACrE,IAAnBqE,CAAwBZ,oBAAoB,CAAC9E,UAAD,EAAajD,KAAb,CAA5C2I;;AACA;AACD;;AAED,UAAI3I,KAAK,IAAI,IAATA,IAAiB,OAAOA,KAAP,KAAiB,QAAtC,EAAgD;AAC9C,YAAIA,KAAK,CAACtB,YAAD,CAALsB,IAAuBA,KAAK,CAACrB,cAAD,CAAhC,EAAkD;AAChD,cAAMkH,GAAG,qBAAQ7F,KAAR,CAAT,CADgD;;;AAIhD,cAAMkQ,QAAQ,GAAGrK,GAAG,CAACnH,YAAD,CAAHmH,GAAoB,SAApBA,GAAgC,WAAjD,CAJgD;;AAOhDA,aAAG,CAACC,IAAJD,GAAW;AACTgG,sBAAU,EAAE/F,IAAI,CAAC3E,GADR;AAET+O,oBAAQ,EAARA,QAFS;AAGTtK,gBAAI,EAAKsK,QAAL,MAAKA,GAAYpK,IAAI,CAACrE,IAALqE,CAAUqK,IAAVrK,CAAe,GAAfA,CAHZ;AAIT5C,kBAAM,EAAE4C,IAAI,CAAC5C,MAJJ;AAKTzB,gBAAI,EAAEqE,IAAI,CAACrE;AALF,WAAXoE,CAPgD;;AAgBhDA,aAAG,CAACuF,aAAJvF,GAAoBsF,mBAAmB,CAACtF,GAAD,EAAM4C,EAAN,CAAvC5C,CAhBgD;;AAmBhDA,aAAG,CAACuF,aAAJvF,CAAkBA,GAAlBA,GAAwBA,GAAxBA,CAnBgD;;AAsBhDA,aAAG,CAACtG,EAAJsG,CAAOA,GAAPA,GAAaA,GAAbA,CAtBgD;;AAyBhDoH,cAAI,CAACpH,GAAG,CAACC,IAAJD,CAASD,IAAV,CAAJqH,GAAsBpH,GAAG,CAACuF,aAA1B6B,CAzBgD;;AA4BhD5H,cAAI,CAACQ,GAAG,CAACC,IAAJD,CAASD,IAAV,CAAJP,GAAsBQ,GAAG,CAACtG,EAA1B8F,CA5BgD;;AA+BhD,cAAIS,IAAI,CAAC3E,GAAL2E,KAAa,MAAjB,EAAyB;AACvB;AACA;AACA;AACA,gBAAID,GAAG,CAAClH,cAAD,CAAP,EAAyB;AACvBwO,0BAAY,CAAC7I,IAAb6I,CAAkBtH,GAAlBsH;AACAjL,iBAAG,CAACT,IAAD,EAAOqO,IAAP,EAAajK,GAAG,CAACuF,aAAjB,CAAHlJ;AAFF,mBAGO;AACLA,iBAAG,CAACT,IAAD,EAAO+J,GAAP,EAAY3F,GAAG,CAACuF,aAAhB,CAAHlJ;AACD;AACF;AAzCH,eA0CO,IAAIlC,KAAK,CAACf,WAAD,CAALe,IAAsBA,KAAK,CAAChB,aAAD,CAA/B,EAAgD;AACrD,cAAM6G,IAAG,qBAAQ7F,KAAR,CAAT,CADqD;;;AAIrD,cAAMkQ,SAAQ,GAAGrK,IAAG,CAAC5G,WAAD,CAAH4G,GAAmB,QAAnBA,GAA8B,UAA/C,CAJqD;;;AAOrD,cAAMD,IAAI,GAAMsK,SAAN,MAAMA,GAAYpK,IAAI,CAACrE,IAALqE,CAAUqK,IAAVrK,CAAe,GAAfA,CAA5B;AACAD,cAAG,CAACC,IAAJD,GAAW;AACTgG,sBAAU,EAAE/F,IAAI,CAAC3E,GADR;AAET+B,kBAAM,EAAE4C,IAAI,CAAC5C,MAFJ;AAGTzB,gBAAI,EAAEqE,IAAI,CAACrE,IAHF;AAITmE,gBAAI,EAAJA,IAJS;AAKTwG,qBAAS,EAAKxG,IAAL,YALA;AAMT6G,uBAAW,EAAK7G,IAAL,cANF;AAOT0G,oBAAQ,EAAK1G,IAAL;AAPC,WAAXC,CARqD;AAmBrD;;AACAA,cAAG,CAAC+G,YAAJ/G,GAAmByF,kBAAkB,CAACzF,IAAD,EAAM4C,EAAN,EAAU8C,UAAV,EAAsBC,GAAtB,CAArC3F,CApBqD;;AAuBrD3D,aAAG,CAACT,IAAD,EAAOoO,YAAP,EAAqBhK,IAAG,CAAC+G,YAAzB,CAAH1K,CAvBqD;;AA0BrD2D,cAAG,CAACuF,aAAJvF,GAAoBqG,yBAAyB,CAACrG,IAAD,EAAM4C,EAAN,CAA7C5C,CA1BqD;;AA6BrDA,cAAG,CAACuF,aAAJvF,CAAkBA,GAAlBA,GAAwBA,IAAxBA,CA7BqD;;AAgCrDoH,cAAI,CAACpH,IAAG,CAACC,IAAJD,CAASD,IAAV,CAAJqH,GAAsBpH,IAAG,CAACuF,aAA1B6B,CAhCqD;AAmCrD;AACA;;AACA,cAAIpH,IAAG,CAAC7G,aAAD,CAAP,EAAwB;AACtBmO,wBAAY,CAAC7I,IAAb6I,CAAkBtH,IAAlBsH;AACAjL,eAAG,CAACT,IAAD,EAAOqO,IAAP,EAAajK,IAAG,CAACuF,aAAjB,CAAHlJ;AAFF,iBAGO;AACLA,eAAG,CAACT,IAAD,EAAO+J,GAAP,EAAY3F,IAAG,CAACuF,aAAhB,CAAHlJ;AACD;AA1CI,eA2CA,IAAIlC,KAAK,CAACpB,cAAD,CAAT,EAA2B;AAChC,cAAMsE,MAAM,GAAG7B,GAAG,CAAC4B,UAAD,EAAakH,GAAb,CAAlB;AACA,cAAMhE,oBAAoB,GAAGoH,4BAA4B,CACvDtK,UADuD,EAEvD9B,GAFuD,EAGvDnB,KAHuD,EAIvDyI,EAJuD,CAAzD;AAMAtC,8BAAoB,CAACjD,MAAD,EAASiH,GAAT,CAApBhE;;AACAZ,aAAG,CAACjB,IAAJiB,CAAS;AAAEpE,eAAG,EAAHA,GAAF;AAAO8B,sBAAU,EAAVA,UAAP;AAAmBkD,gCAAoB,EAApBA;AAAnB,WAATZ;AATK,eAUA,IAAIvF,KAAK,CAACjB,aAAD,CAAT,EAA0B;AAC/BuG,aAAG,CAAChB,IAAJgB,CAAS;AAAEnE,eAAG,EAAHA,GAAF;AAAO8B,sBAAU,EAAVA,UAAP;AAAmB5C,mBAAO,EAAEL,KAAK,CAACT;AAAlC,WAAT+F;AADK,eAEA,IAAItF,KAAK,CAACnB,cAAD,CAAT,EAA2B;AAChC,cAAMgH,KAAG,qBAAQ7F,KAAR,CAAT,CADgC;;;AAIhC,cAAM4F,KAAI,kBAAgBE,IAAI,CAACrE,IAALqE,CAAUqK,IAAVrK,CAAe,GAAfA,CAA1B;;AACAD,eAAG,CAACC,IAAJD,GAAW;AACTD,gBAAI,EAAJA,KADS;AAETiG,sBAAU,EAAE/F,IAAI,CAAC3E,GAFR;AAGT+B,kBAAM,EAAE4C,IAAI,CAAC5C,MAHJ;AAITzB,gBAAI,EAAEqE,IAAI,CAACrE,IAJF;AAKT2K,qBAAS,EAAKxG,KAAL,YALA;AAMT6G,uBAAW,EAAK7G,KAAL,cANF;AAOT0G,oBAAQ,EAAK1G,KAAL;AAPC,WAAXC;AAUA,cAAM2J,aAAa,GAAGR,mBAAmB,CAACnJ,KAAD,EAAM4C,EAAN,EAAU8C,UAAV,EAAsBC,GAAtB,CAAzC;AAEA,cAAMJ,aAAa,GAAGmE,0BAA0B,CAC9C1J,KAD8C,EAE9C4C,EAF8C,EAG9C+G,aAH8C,CAAhD;AAMA3J,eAAG,CAACuF,aAAJvF,GAAoBuF,aAApBvF;;AAEAyI,YAAE,CAAChK,IAAHgK,CAAQzI,KAARyI;AAzBK,eA0BA,IAAI/N,aAAa,CAACP,KAAD,CAAjB,EAA0B;AAC/B,cAAMoQ,QAAQ,GAAG/O,GAAG,CAACI,IAAD,EAAO0I,GAAP,CAApB;;AACA,cAAIiG,QAAQ,IAAI,IAAhB,EAAsB;AACpBlO,eAAG,CAACT,IAAD,EAAO0I,GAAP,EAAY,EAAZ,CAAHjI;AACD;;AACD6N,mCAAyB,CAAC/P,KAAD,EAAQyB,IAAR,CAAzBsO;AALK,eAMA;AACLC,4BAAkB;AACnB;AApIH,aAqIO;AACLA,0BAAkB;AACnB;AA7JH,MADgC;AAAlC;;AAiKArH,oBAAkB,GAAGA,kBAAkB,CAAC0H,IAAnB1H,CAAwB,UAAC2H,CAAD,EAAIC,CAAJ,EAAU;AACrD,QAAMC,KAAK,GAAGF,CAAC,CAAC7O,IAAF6O,CAAOH,IAAPG,CAAY,GAAZA,CAAd;AACA,QAAMG,KAAK,GAAGF,CAAC,CAAC9O,IAAF8O,CAAOJ,IAAPI,CAAY,GAAZA,CAAd;;AACA,QAAIC,KAAK,GAAGC,KAAZ,EAAmB;AACjB,aAAO,CAAC,CAAR;AACD;;AACD,QAAID,KAAK,GAAGC,KAAZ,EAAmB;AACjB,aAAO,CAAP;AACD;;AACD,WAAO,CAAP;AATmB,IAArB9H;AAYAoH,2BAAyB,CAAC9P,KAAD,EAAQ,EAAR,CAAzB8P;AAEA7C,kBAAgB,CAACC,YAAD,EAAe3B,GAAf,EAAoByB,IAApB,EAA0BF,IAA1B,CAAhBG;AAEA,SAAO;AACLD,QAAI,EAAJA,IADK;AAELzB,OAAG,EAAHA,GAFK;AAGLnG,QAAI,EAAJA,IAHK;AAILE,OAAG,EAAHA,GAJK;AAKLD,OAAG,EAAHA,GALK;AAML2I,OAAG,EAAHA,GANK;AAOL9D,OAAG,EAAHA,GAPK;AAQLmE,MAAE,EAAFA,EARK;AASLwB,QAAI,EAAJA,IATK;AAUL/C,QAAI,EAAJA,IAVK;AAWLpE,sBAAkB,EAAlBA;AAXK,GAAP;AAaD;;ACnNM,SAAS+H,WAAT,CAAqBzQ,KAArB,EAA4B0Q,OAA5B,EAA0C;AAAA,MAAdA,OAAc;AAAdA,WAAc,GAAJ,EAAVA;AAAc;;AAC/C,MAAMC,UAAU,GAAGhQ,KAAK,CAACX,KAAD,CAAxB;AACA,iBAYI0Q,OAZJ;AAAA,MACEE,SADF,YACEA,OADF;AAAA,mCAEEC,QAFF;AAAA,MAEEA,QAFF,kCAEalU,OAAO,CAACC,GAARD,CAAYE,QAAZF,KAAyB,YAFtC;AAAA,uCAGEyF,YAHF;AAAA,MAGEA,YAHF,sCAGiB,KAHjB;AAAA,oCAIE0O,SAJF;AAAA,MAIEA,SAJF,mCAIc,EAJd;AAAA,uCAKEnB,YALF;AAAA,MAKEA,YALF,sCAKiB,EALjB;AAAA,qCAMErE,UANF;AAAA,MAMEA,UANF,oCAMe,EANf;AAAA,qCAOEyF,UAPF;AAAA,MAOEA,UAPF,oCAOe,EAPf;AAAA,sCAQEC,WARF;AAAA,MAQEA,WARF,qCAQgB,KARhB;AAAA,+BASEC,IATF;AAAA,MASQC,SATR;AAAA,kCAUEC,OAVF;AAAA,MAUEA,OAVF,iCAUY,CAVZ;AAAA,uCAWEC,eAXF;AAAA,MAWEA,eAXF,sCAWoB,UAACpL,WAAD;AAAA,WAAiBA,WAAjB;AAXpB;;AAcA,MAAMqL,gBAAgB,GAAG,SAAnBA,gBAAmB,CAACC,QAAD;AAAA,2CACpBA,QADoB;AAEvBC,UAAI,EAAE9F,OAAe,UAACtH,CAAD,EAAIsB,OAAJ;AAAA,eAAgBA,OAAhB;AAAf;AAFiB;AAAzB;;AAKA,MAAM+C,EAAE,GAAG,EAAX;AAEA,MAAIgJ,QAAQ,GAAGH,gBAAgB,CAACV,UAAD,CAA/B;AACA,MAAIc,aAAa,GAAG,EAApB;;AAEA,MAAMlJ,UAAU,GAAG,SAAbA,UAAa,CAACiB,UAAD;AAAA,iBACb0H,SADa,UACCC,OADD,UAEf3H,UAAU,CAACzH,MAAXyH,GAAoB,CAApBA,SAA4BA,UAAU,CAAC0G,IAAX1G,CAAgB,GAAhBA,CAA5B,SAAsD,EAFvC;AAAnB;;AAIA,MAAMM,SAAS,GAAGlB,eAAe,CAACL,UAAD,EAAaC,EAAb,CAAjC;AACA,MAAMkJ,iBAAiB,GAAG7H,uBAAuB,CAACC,SAAD,EAAYtB,EAAZ,CAAjD;;AAEA,MAAMwB,YAAY,GAAG,SAAfA,YAAe,CAACb,SAAD;AAAA,WAAeX,EAAE,CAACC,EAAHD,CAAMwE,IAANxE,CAAW,cAAXA,EAA2BW,SAA3BX,CAAf;AAArB;;AAEA,MAAMmJ,kBAAkB,GAAG,SAArBA,kBAAqB,CAACzS,KAAD,EAAgB;AAAA,QAAfA,KAAe;AAAfA,WAAe,GAAP,EAARA;AAAe;;AACzC,QAAMmI,IAAI,GAAGqI,oBAAoB,CAAC8B,QAAD,EAAWtS,KAAX,EAAkBoM,UAAlB,EAA8B9C,EAA9B,CAAjC;AACAA,MAAE,CAACC,EAAHD,mCACKnB,IADL;AAEEjH,aAAO,EAAEgR,eAAe,CACtBjM,aAAa,CAAC/C,YAAD,EAAeiF,IAAI,CAACjC,IAApB,EAA0BiC,IAAI,CAAChC,GAA/B,EAAoCgC,IAAI,CAAC/B,GAAzC,CADS;AAF1B;AAFF;;AAUA,MAAMsM,qBAAqB,GAAG,SAAxBA,qBAAwB;AAAA,WAAM;AAAA,aAAM,UAACrS,MAAD,EAAY;AACpD,YAAIA,MAAM,IAAI,IAAd,EAAoB;AAClBkS,uBAAa,CAACpN,IAAdoN,CAAmBlS,MAAnBkS;AACD;;AACD,eAAOjV,SAAP;AAJkC;AAAN;AAA9B;;AAOA,MAAMqV,gBAAgB,GACpBjB,SAAO,KACNC,QAAQ,IACT,OAAOxV,MAAP,KAAkB,WADjBwV,IAEDxV,MAAM,CAACyW,oCAFNjB,GAGGxV,MAAM,CAACyW,oCAAPzW,CAA4C;AAC1C4V,QAAI,EAAEC;AADoC,GAA5C7V,CAHHwV,GAMGkB,OAPG,CADT;AAUAJ,oBAAkB,CAAChC,YAAD,CAAlBgC;AAEA,MAAMK,mBAAmB,IACvB7D,kCAAkC,CAAC3F,EAAD,CADX,SAEpBuI,UAFoB,GAGvBkB,UAHuB,EAIvBpF,wBAAwB,CAACrE,EAAD,CAJD,EAKvB4F,uBAAuB,CAAC5F,EAAD,CALA,EAMvBkJ,iBANuB,EAAzB;;AASA,MAAIV,WAAJ,EAAiB;AACfgB,uBAAmB,CAAC3N,IAApB2N,CAAyBJ,qBAAzBI;AACD;;AAED,MAAMnW,KAAK,GAAGqW,aAAgB,CAC5B1J,EAAE,CAACC,EAAHD,CAAMpI,OADsB,EAE5BoI,EAAE,CAACC,EAAHD,CAAM0B,GAFsB,EAG5B2H,gBAAgB,MAAhBA,UAAiBM,eAAe,MAAfA,SAAmBH,mBAAnBG,CAAjB,SAA6DrB,SAA7D,EAH4B,CAA9B;AAMAjV,OAAK,CAACyB,SAANzB,CAAgB,YAAM;AACpB2M,MAAE,CAACC,EAAHD,CAAMwF,GAANxF,CAAUyF,WAAVzF,GAAwB,KAAxBA;AADF;AAIAA,IAAE,CAAC1K,QAAH0K,GAAc3M,KAAK,CAACiC,QAApB0K;AACAA,IAAE,CAAC/L,QAAH+L,GAAc3M,KAAK,CAACY,QAApB+L;;AAEA,MAAM4J,kBAAkB,GAAG,SAArBA,kBAAqB,GAAM;AAC/B3R,UAAM,CAACM,IAAPN,CAAY5E,KAAK,CAACiC,QAAlB2C,EAA4BY,OAA5BZ,CAAoC,UAAC4R,UAAD,EAAgB;AAClD,aAAOxW,KAAK,CAACiC,QAANjC,CAAewW,UAAfxW,CAAP;AADF;AAGA4E,UAAM,CAACM,IAAPN,CAAY+H,EAAE,CAACC,EAAHD,CAAM+C,GAAlB9K,EAAuBY,OAAvBZ,CAA+B,UAACS,GAAD,EAAS;AACtCrF,WAAK,CAACiC,QAANjC,CAAeqF,GAAfrF,IAAsB2M,EAAE,CAACC,EAAHD,CAAM+C,GAAN/C,CAAUtH,GAAVsH,CAAtB3M;AADF;AAJF;;AASAuW,oBAAkB;;AAElB,MAAME,WAAW,GAAG,SAAdA,WAAc,CAACC,SAAD,EAAe;AACjC,QAAM1Q,YAAY,GAAGhG,KAAK,CAACY,QAANZ,EAArB;;AACA,QAAI0W,SAAJ,EAAe;AACb,aAAO1Q,YAAY,CAAC0Q,SAAD,CAAnB;AACD;;AACDZ,sBAAkB,CAAC9P,YAAD,CAAlB8P;AACA9V,SAAK,CAAC2W,cAAN3W,CAAqB2M,EAAE,CAACC,EAAHD,CAAMpI,OAA3BvE;AACAmO,gBAAY,CAACxB,EAAE,CAACC,EAAHD,CAAM0B,GAAP,CAAZF;AACAoI,sBAAkB;AARpB;;AAWA,MAAM9T,mBAAkB,GAAGyL,iCAAiC,CAC1DxB,UAD0D,EAE1DyB,YAF0D,EAG1DxB,EAH0D,CAA5D;;AAMA,SAAO/H,MAAM,CAACgS,MAAPhS,CAAc5E,KAAd4E,EAAqB;AAC1BiS,YAAQ,EAAE,kBAACxR,GAAD,EAAMyR,WAAN,EAAsB;AAC9B,UAAInB,QAAQ,CAACtQ,GAAD,CAARsQ,IAAiB7U,OAAO,CAACC,GAARD,CAAYE,QAAZF,KAAyB,YAA9C,EAA4D;AAC1Dd,aAAK,CAAC+W,WAAN/W,CAAkBqF,GAAlBrF;AACD;;AACD2V,cAAQ,CAACtQ,GAAD,CAARsQ,GAAgBmB,WAAhBnB;AACAc,iBAAW,GALmB;AAO9B;;AACA,UAAMO,mBAAmB,GAAG9I,iCAAiC,CAC3DxB,UAD2D,EAE3DyB,YAF2D,EAG3DxB,EAH2D,EAI3DtH,GAJ2D,CAA7D;AAMA,aAAO;AACL5C,0BAAkB,EAAE;AAAA,iBAAMuU,mBAAN;AAAA;AADf,OAAP;AAfwB;AAmB1BC,sBAAkB,EAAE,8BAAM;AACxBrB,mBAAa,GAAG,EAAhBA;AApBwB;AAsB1B9T,cAAU,EAAE;AAAA,aAAM6K,EAAE,CAACC,EAAHD,CAAM+C,GAAZ;AAtBc;AAuB1BwH,gBAAY,EAAE;AAAA,aAAMvK,EAAE,CAACC,EAAHD,CAAMqH,IAAZ;AAvBY;AAwB1BmD,oBAAgB,EAAE;AAAA,uBAAUvB,aAAV;AAxBQ;AAyB1BpT,WAAO,EAAE;AACPsL,WAAK,EAAEG,SAAS,CAACH,KADV;AAEPC,WAAK,EAAEE,SAAS,CAACF,KAFV;AAGPtL,wBAAkB,EAAE;AAAA,eAAMA,mBAAN;AAAA;AAHb,KAzBiB;AA8B1B2U,eAAW,EAAE,qBAACC,QAAD,EAAc;AACzB1B,cAAQ,GAAGH,gBAAgB,CAAC6B,QAAD,CAA3B1B;AACAc,iBAAW;AAhCa;AAkC1BM,eAAW,EAAE,qBAAC1R,GAAD,EAAS;AACpB,UAAI,CAACsQ,QAAQ,CAACtQ,GAAD,CAAb,EAAoB;AAClB;AACD;;AACD,aAAOsQ,QAAQ,CAACtQ,GAAD,CAAf;AACAoR,iBAAW,CAACpR,GAAD,CAAXoR;AACD;AAxCyB,GAArB7R,CAAP;AA0CD;;ACvKM,SAAS0S,kBAAT,CAA4BnT,KAA5B,EAAmCC,MAAnC,EAAgD;AAAA,MAAbA,MAAa;AAAbA,UAAa,GAAJ,EAATA;AAAa,IACrD;;;AACA,gBAA+CA,MAA/C;AAAA,mCAAQqL,UAAR;AAAA,MAAoB8H,iBAApB,mCAAwC,EAAxC;AAEA,MAAMlY,YAAY,GAAGC,aAAa,EAAlC;;AAEA,WAASkY,QAAT,OAA0D;AAAA,QAAtCC,QAAsC,QAAtCA,QAAsC;AAAA,QAA5BC,YAA4B,QAA5BA,YAA4B;AAAA,QAAdjI,UAAc,QAAdA,UAAc,EACxD;AACA;;AACA,QAAIA,UAAU,IAAI,IAAlB,EAAwB;AACtB,UAAMkI,cAAc,GAClB,OAAOlI,UAAP,KAAsB,UAAtB,GACIA,UAAU,CAAC8H,iBAAD,CADd,GAEI9H,UAHN;AAIA,UAAMmI,QAAQ,GAAGhT,MAAM,CAACM,IAAPN,CAAY+S,cAAZ/S,CAAjB;AACA,UAAMiT,UAAU,GAAGjT,MAAM,CAACM,IAAPN,CAAY2S,iBAAZ3S,EAA+BkT,MAA/BlT,CACjB,UAACmT,CAAD;AAAA,eAAO,CAACH,QAAQ,CAACI,QAATJ,CAAkBG,CAAlBH,CAAR;AADiB,QAAnB;AAGAC,gBAAU,CAACrS,OAAXqS,CAAmB,UAACE,CAAD,EAAO;AACxB,eAAOR,iBAAiB,CAACQ,CAAD,CAAxB;AADF;AAGAnT,YAAM,CAACgS,MAAPhS,CAAc2S,iBAAd3S,EAAiC+S,cAAjC/S;AACD;;AAED,QAAM5E,KAAK,GAAG6I,UAAU,CACtB;AAAA,aACE+L,WAAW,CAAC,OAAOzQ,KAAP,KAAiB,UAAjB,GAA8BA,KAAK,CAACuT,YAAD,CAAnC,GAAoDvT,KAArD,kCACNC,MADM;AAET6T,0BAAkB,EAAEV;AAFX,SADb;AADsB,OAMtB,EANsB,CAAxB;AAQA,wBACEtO,oBAAC5J,YAAD,CAAcmY,QAAd;AAAuBtT,WAAK,EAAElE;AAA9B,OAAsCyX,QAAtC,CADF;AAGD;;AAED,WAASvV,QAAT,GAAoB;AAClB,WAAOjC,UAAU,CAACZ,YAAD,CAAjB;AACD;;AAED,SAAO;AACLmY,YAAQ,EAARA,QADK;AAELtV,YAAQ,EAARA,QAFK;AAGLrC,iBAAa,EAAEF,oBAAoB,CAACN,YAAD,CAH9B;AAILuC,mBAAe,EAAED,sBAAsB,CAACtC,YAAD,CAJlC;AAKL2C,oBAAgB,EAAED,uBAAuB,CAAC1C,YAAD,CALpC;AAML+C,sBAAkB,EAAED,yBAAyB,CAAC9C,YAAD;AANxC,GAAP;AAQD;AC7DD;AACA;AACA;AACA;;;AAEO,SAAS6Y,eAAT,CAAyBC,OAAzB,EAAkCC,QAAlC,EAA4ChU,MAA5C,EAAyD;AAAA,MAAbA,MAAa;AAAbA,UAAa,GAAJ,EAATA;AAAa;;AAC9D,MAAMiU,SAAS,GAAGjU,MAAM,CAACiU,SAAPjU,IAAoB,IAAtC;AACA,MAAMkU,SAAS,GAAGlU,MAAM,CAACkU,SAAPlU,IAAoB,IAAtC;;AAEA,WAASmU,uBAAT,CAAiClT,GAAjC,EAAsC;AACpC,QAAIgT,SAAS,IAAIA,SAAS,CAACG,OAAVH,CAAkBhT,GAAlBgT,MAA2B,CAAC,CAA7C,EAAgD,OAAO,IAAP;AAChD,QAAIC,SAAS,IAAIA,SAAS,CAACE,OAAVF,CAAkBjT,GAAlBiT,MAA2B,CAAC,CAA7C,EAAgD,OAAO,IAAP;AAChD,WAAO,KAAP;AACD;;AAED,SAAO;AACL7M,MAAE,EAAE,aAACD,IAAD,EAAOnG,GAAP,EAAYoT,SAAZ;AAAA,aACF,CAACF,uBAAuB,CAAClT,GAAD,CAAxB,IAAiC8S,OAAjC,GACIA,OAAO,CAAC3M,IAAD,EAAOnG,GAAP,EAAYoT,SAAZ,CADX,GAEIjN,IAHF;AADC;AAKLM,OAAG,EAAE,aAACN,IAAD,EAAOnG,GAAP,EAAYoT,SAAZ;AAAA,aACH,CAACF,uBAAuB,CAAClT,GAAD,CAAxB,IAAiC+S,QAAjC,GACIA,QAAQ,CAAC5M,IAAD,EAAOnG,GAAP,EAAYoT,SAAZ,CADZ,GAEIjN,IAHD;AAAA;AALA,GAAP;AAUD;ACzBD;;;AAKO,SAASkN,aAAT,OAA4C;AAAA,MAAnBjB,QAAmB,QAAnBA,QAAmB;AAAA,MAATzX,KAAS,QAATA,KAAS;AACjD,sBACEiJ,oBAAC5J,YAAD,CAAcmY,QAAd;AAAuBtT,SAAK,EAAElE;AAA9B,KAAsCyX,QAAtC,CADF;AAGD;;ACLM,SAASkB,aAAT,CAAuBC,YAAvB,EAAqCC,YAArC,EAAwDC,aAAxD,EAAuE;AAAA,MAAlCD,YAAkC;AAAlCA,gBAAkC,GAAnB,EAAfA;AAAkC;;AAC5E,MAAME,QAAQ,GAAG5Y,MAAM,EAAvB;AAEA,MAAM6Y,SAAS,GAAG7Y,MAAM,EAAxB;AAEA,MAAMH,KAAK,GAAG6I,UAAU,CAAC,YAAM;AAC7B,QAAMoQ,aAAa,GACjBF,QAAQ,CAACrY,OAATqY,IAAoB,IAApBA,GAA2BA,QAAQ,CAACrY,OAATqY,CAAiBnY,QAAjBmY,EAA3BA,GAAyDpY,SAD3D;AAEA,QAAMyD,MAAM,GACV0U,aAAa,IAAI,IAAjBA,GACIA,aAAa,CAACG,aAAD,EAAgBD,SAAS,CAACtY,OAA1B,CADjBoY,GAEInY,SAHN;;AAIA,QAAMuY,MAAM,GAAGtE,WAAW,CAACgE,YAAY,CAACK,aAAD,CAAb,EAA8B7U,MAA9B,CAA1B;;AACA4U,aAAS,CAACtY,OAAVsY,GAAoB5U,MAApB4U;AACAD,YAAQ,CAACrY,OAATqY,GAAmBG,MAAnBH;AACA,WAAOG,MAAP;AAVsB,KAWrBL,YAXqB,CAAxB;;AAaA,kBAAwCxW,QAAQ,CAAC;AAAA,WAAMrC,KAAK,CAACY,QAANZ,EAAN;AAAD,IAAhD;AAAA,MAAOgG,YAAP;AAAA,MAAqBmT,eAArB;;AAEAzZ,WAAS,CACP,YAAM;AACJyZ,mBAAe,CAACnZ,KAAK,CAACY,QAANZ,EAAD,CAAfmZ;AACAnZ,SAAK,CAACyB,SAANzB,CAAgB,YAAM;AACpB,UAAMsN,SAAS,GAAGtN,KAAK,CAACY,QAANZ,EAAlB;;AACA,UAAIgG,YAAY,KAAKsH,SAArB,EAAgC;AAC9B6L,uBAAe,CAAC7L,SAAD,CAAf6L;AACD;AAJH;AAHK,KAUP,CAACnZ,KAAD,CAVO,CAATN;AAaA,SAAO,CAACsG,YAAD,EAAehG,KAAK,CAAC8B,UAAN9B,EAAf,EAAmCA,KAAnC,CAAP;AACD","names":["StoreContext","createContext","useIsomorphicLayoutEffect","window","useLayoutEffect","useEffect","createStoreStateHook","Context","useStoreState","mapState","equalityFn","store","useContext","mapStateRef","useRef","stateRef","mountedRef","subscriptionMapStateError","useReducer","s","forceRender","current","undefined","getState","err","process","env","NODE_ENV","errorMessage","message","stack","Error","checkMapState","newState","isStateEqual","unsubscribe","subscribe","EasyPeasyContext","createStoreActionsHook","useStoreActions","mapActions","getActions","createStoreDispatchHook","useStoreDispatch","dispatch","useStore","createStoreRehydratedHook","useStoreRehydrated","useState","rehydrated","setRehydrated","persist","resolveRehydration","then","createTypedHooks","actionSymbol","actionOnSymbol","computedSymbol","effectOnSymbol","persistSymbol","reducerSymbol","thunkOnSymbol","thunkSymbol","debug","state","isDraft","actionOn","targetResolver","fn","action","defaultStateResolvers","computed","fnOrStateResolvers","stateResolvers","unstable_effectOn","dependencyResolvers","generic","value","model","config","thunkOn","thunk","reducer","easyPeasyImmer","isPlainObject","obj","proto","Object","getPrototypeOf","clone","source","recursiveClone","next","keys","reduce","acc","key","getOwnPropertyDescriptor","get","forEach","isPromise","x","path","target","cur","newify","currentPath","currentState","finalValue","length","slice","set","idx","createSimpleProduce","disableImmer","simpleProduce","Immer","useProxies","Proxy","revocable","Reflect","autoFreeze","draft","createDraft","result","finishDraft","parentPath","parent","pReduce","iterable","initialValue","Promise","resolve","reject","iterator","Symbol","index","total","element","done","all","catch","pSeries","tasks","results","_","task","push","areInputsEqual","newInputs","lastInputs","i","useMemoOne","getResult","inputs","initial","React","committed","isInputMatch","Boolean","cache","createReducer","_aRD","_cR","_cP","runActionReducerAtPath","actionReducer","payload","reducerForActions","type","def","meta","reducerForCustomReducers","original","rootReducer","stateAfterActions","bindComputedProperty","parentState","noopStorage","getItem","setItem","removeItem","getBrowerStorage","storageName","storageCache","localStorage","sessionStorage","createStorageWrapper","storage","transformers","console","warn","outTransformers","reverse","serialize","data","in","JSON","stringify","deserialize","parse","out","isAsync","wrapped","extractPersistConfig","persistdef","allow","deny","mergeStrategy","resolvePersistTargets","targets","findIndex","createPersistenceClearer","persistKey","_r","_i","_persistenceConfig","map","createPersistor","persistPromise","isPersisting","nextPersistOperation","timingMethod","requestIdleCallback","requestAnimationFrame","nextState","operation","persistRootState","persistTargets","stateToPersist","targetPath","rawValue","finally","clear","flush","createPersistMiddleware","persistor","rehydrateStateFromPersistIfNeeded","replaceState","root","_dS","rehydrating","persistInstance","hasDataModelChanged","dataModel","rehydratingModelData","Array","isArray","applyRehydrationStrategy","persistedState","targetState","setAt","currentTargetState","currentPersistedState","rehydate","getItemResult","createActionCreator","actionCreator","resolvedTargets","createThunkHandler","injections","_aC","fail","helpers","getStoreActions","getStoreState","actionName","logThunkEventListenerError","log","handleEventDispatchErrors","dispatcher","createThunkActionsCreator","dispatchStart","startType","dispatchFail","failType","error","dispatchSuccess","successType","failure","_failure","thunkHandler","resolved","createListenerMiddleware","_lAM","sourceAction","_aCD","bindListenerdefs","listenerdefs","targetTypes","targetType","listenerReg","createComputedPropertyBinder","runOnce","prevInputs","prevValue","createComputedProperty","storeState","defineProperty","configurable","enumerable","resolver","_cS","isInReducer","match","createComputedPropertiesMiddleware","createEffectsMiddleware","_e","prevState","prevLocal","nextLocal","prevDependencies","nextDependencies","hasChanged","some","dependency","logEffectError","createEffectHandler","actions","dispose","change","disposeResult","effectResult","logEffectEventListenerError","createEffectActionsCreator","effectHandler","previousDependencies","prev","extractDataFromModel","initialState","actionThunks","_lAC","recursiveExtractFromModel","handleValueAsState","initialParentRef","category","join","existing","sort","a","b","aPath","bPath","createStore","options","modelClone","compose","devTools","enhancers","middleware","mockActions","name","storeName","version","reducerEnhancer","bindReplaceState","modelDef","ePRS","modeldef","mockedActions","persistMiddleware","bindStoreInternals","mockActionsMiddleware","composeEnhancers","__REDUX_DEVTOOLS_EXTENSION_COMPOSE__","reduxCompose","easyPeasyMiddleware","reduxThunk","reduxCreateStore","applyMiddleware","bindActionCreators","actionsKey","rebindStore","removeKey","replaceReducer","assign","addModel","modelForKey","removeModel","addModelRehydration","clearMockedActions","getListeners","getMockedActions","reconfigure","newModel","createContextStore","mutableInjections","Provider","children","runtimeModel","nextInjections","nextKeys","removeKeys","filter","k","includes","originalInjections","createTransform","inbound","outbound","whitelist","blacklist","whitelistBlacklistCheck","indexOf","fullState","StoreProvider","useLocalStore","modelCreator","dependencies","configCreator","storeRef","configRef","previousState","_store","setCurrentState"],"sources":["../src/context.js","../src/hooks.js","../src/constants.js","../src/helpers.js","../src/lib.js","../src/create-reducer.js","../src/persistence.js","../src/actions.js","../src/thunks.js","../src/listeners.js","../src/computed-properties.js","../src/effects.js","../src/extract-data-from-model.js","../src/create-store.js","../src/create-context-store.js","../src/create-transform.js","../src/provider.js","../src/use-local-store.js"],"sourcesContent":["import { createContext } from 'react';\n\nconst StoreContext = createContext();\n\nexport default StoreContext;\n","import {\n  useContext,\n  useEffect,\n  useLayoutEffect,\n  useReducer,\n  useRef,\n  useState,\n} from 'react';\nimport EasyPeasyContext from './context';\n\n// React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser. We need useLayoutEffect to ensure the store\n// subscription callback always has the selector from the latest render commit\n// available, otherwise a store update may happen between render and the effect,\n// which may cause missed updates; we also must ensure the store subscription\n// is created synchronously, otherwise a store update may occur before the\n// subscription is created and an inconsistent state may be observed\nconst useIsomorphicLayoutEffect =\n  typeof window !== 'undefined' ? useLayoutEffect : useEffect;\n\nexport function createStoreStateHook(Context) {\n  return function useStoreState(mapState, equalityFn) {\n    const store = useContext(Context);\n    const mapStateRef = useRef(mapState);\n    const stateRef = useRef();\n    const mountedRef = useRef(true);\n    const subscriptionMapStateError = useRef();\n\n    const [, forceRender] = useReducer((s) => s + 1, 0);\n\n    if (\n      subscriptionMapStateError.current ||\n      mapStateRef.current !== mapState ||\n      stateRef.current === undefined\n    ) {\n      try {\n        stateRef.current = mapState(store.getState());\n      } catch (err) {\n        if (process.env.NODE_ENV === 'development') {\n          let errorMessage = `Error in useStoreState: ${err.message}.`;\n          if (subscriptionMapStateError.current) {\n            errorMessage += `\\nMaybe related to:\\n${subscriptionMapStateError.current.stack}`;\n          }\n          throw new Error(errorMessage);\n        }\n        throw subscriptionMapStateError.current || err;\n      }\n    }\n\n    useIsomorphicLayoutEffect(() => {\n      mapStateRef.current = mapState;\n      subscriptionMapStateError.current = undefined;\n    });\n\n    useIsomorphicLayoutEffect(() => {\n      const checkMapState = () => {\n        try {\n          const newState = mapStateRef.current(store.getState());\n\n          const isStateEqual =\n            typeof equalityFn === 'function'\n              ? equalityFn(stateRef.current, newState)\n              : stateRef.current === newState;\n\n          if (isStateEqual) {\n            return;\n          }\n\n          stateRef.current = newState;\n        } catch (err) {\n          // see https://github.com/reduxjs/react-redux/issues/1179\n          // There is a possibility mapState will fail due to stale state or\n          // props, therefore we will just track the error and force our\n          // component to update. It should then receive the updated state\n          subscriptionMapStateError.current = err;\n        }\n        if (mountedRef.current) {\n          forceRender({});\n        }\n      };\n      const unsubscribe = store.subscribe(checkMapState);\n      checkMapState();\n      return () => {\n        mountedRef.current = false;\n        unsubscribe();\n      };\n    }, []);\n\n    return stateRef.current;\n  };\n}\n\nexport const useStoreState = createStoreStateHook(EasyPeasyContext);\n\nexport function createStoreActionsHook(Context) {\n  return function useStoreActions(mapActions) {\n    const store = useContext(Context);\n    return mapActions(store.getActions());\n  };\n}\n\nexport const useStoreActions = createStoreActionsHook(EasyPeasyContext);\n\nexport function createStoreDispatchHook(Context) {\n  return function useStoreDispatch() {\n    const store = useContext(Context);\n    return store.dispatch;\n  };\n}\n\nexport const useStoreDispatch = createStoreDispatchHook(EasyPeasyContext);\n\nexport function useStore() {\n  return useContext(EasyPeasyContext);\n}\n\nexport function createStoreRehydratedHook(Context) {\n  return function useStoreRehydrated() {\n    const store = useContext(Context);\n    const [rehydrated, setRehydrated] = useState(false);\n    useEffect(() => {\n      store.persist.resolveRehydration().then(() => setRehydrated(true));\n    }, []);\n    return rehydrated;\n  };\n}\n\nexport const useStoreRehydrated = createStoreRehydratedHook(EasyPeasyContext);\n\nexport function createTypedHooks() {\n  return {\n    useStoreActions,\n    useStoreDispatch,\n    useStoreState,\n    useStoreRehydrated,\n    useStore,\n  };\n}\n","export const actionSymbol = '$_a';\nexport const actionOnSymbol = '$_aO';\nexport const computedSymbol = '$_c';\nexport const effectOnSymbol = '$_e';\nexport const persistSymbol = '$_p';\nexport const reducerSymbol = '$_r';\nexport const thunkOnSymbol = '$_tO';\nexport const thunkSymbol = '$_t';\n","import { isDraft, current } from 'immer';\nimport {\n  actionOnSymbol,\n  actionSymbol,\n  computedSymbol,\n  effectOnSymbol,\n  persistSymbol,\n  reducerSymbol,\n  thunkOnSymbol,\n  thunkSymbol,\n} from './constants';\n\nexport const debug = (state) => {\n  if (isDraft(state)) {\n    return current(state);\n  }\n  return state;\n};\n\nexport const actionOn = (targetResolver, fn) => ({\n  [actionOnSymbol]: true,\n  fn,\n  targetResolver,\n});\n\nexport const action = (fn) => ({\n  [actionSymbol]: true,\n  fn,\n});\n\nconst defaultStateResolvers = [(state) => state];\n\nexport const computed = (fnOrStateResolvers, fn) => {\n  if (typeof fn === 'function') {\n    return {\n      [computedSymbol]: true,\n      fn,\n      stateResolvers: fnOrStateResolvers,\n    };\n  }\n  return {\n    [computedSymbol]: true,\n    fn: fnOrStateResolvers,\n    stateResolvers: defaultStateResolvers,\n  };\n};\n\nexport function unstable_effectOn(dependencyResolvers, fn) {\n  return {\n    [effectOnSymbol]: true,\n    dependencyResolvers,\n    fn,\n  };\n}\n\nexport function generic(value) {\n  return value;\n}\n\nexport const persist = (model, config) =>\n  // if we are not running in a browser context this becomes a no-op\n  typeof window === 'undefined'\n    ? model\n    : {\n        ...model,\n        [persistSymbol]: config,\n      };\n\nexport const thunkOn = (targetResolver, fn) => ({\n  [thunkOnSymbol]: true,\n  fn,\n  targetResolver,\n});\n\nexport const thunk = (fn) => ({\n  [thunkSymbol]: true,\n  fn,\n});\n\nexport const reducer = (fn) => ({\n  [reducerSymbol]: true,\n  fn,\n});\n","import React from 'react';\nimport { Immer, isDraft } from 'immer';\n\n/**\n * We create our own immer instance to avoid potential issues with autoFreeze\n * becoming default enabled everywhere. We want to disable autofreeze as it\n * does not suit the design of Easy Peasy.\n * https://github.com/immerjs/immer/issues/681#issuecomment-705581111\n */\nlet easyPeasyImmer;\n\nexport function isPlainObject(obj) {\n  if (typeof obj !== 'object' || obj === null) return false;\n\n  let proto = obj;\n  while (Object.getPrototypeOf(proto) !== null) {\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return Object.getPrototypeOf(obj) === proto;\n}\n\nexport function clone(source) {\n  function recursiveClone(current) {\n    const next = Object.keys(current).reduce((acc, key) => {\n      if (Object.getOwnPropertyDescriptor(current, key).get == null) {\n        acc[key] = current[key];\n      }\n      return acc;\n    }, {});\n    Object.keys(next).forEach((key) => {\n      if (isPlainObject(next[key])) {\n        next[key] = recursiveClone(next[key]);\n      }\n    });\n    return next;\n  }\n  return recursiveClone(source);\n}\n\nexport function isPromise(x) {\n  return x != null && typeof x === 'object' && typeof x.then === 'function';\n}\n\nexport function get(path, target) {\n  return path.reduce(\n    (acc, cur) => (isPlainObject(acc) ? acc[cur] : undefined),\n    target,\n  );\n}\n\nexport function newify(currentPath, currentState, finalValue) {\n  if (currentPath.length === 0) {\n    return finalValue;\n  }\n  const newState = { ...currentState };\n  const key = currentPath[0];\n  if (currentPath.length === 1) {\n    newState[key] = finalValue;\n  } else {\n    newState[key] = newify(currentPath.slice(1), newState[key], finalValue);\n  }\n  return newState;\n}\n\nexport function set(path, target, value) {\n  if (path.length === 0) {\n    if (typeof value === 'object') {\n      Object.keys(target).forEach((key) => {\n        delete target[key];\n      });\n      Object.keys(value).forEach((key) => {\n        target[key] = value[key];\n      });\n    }\n    return;\n  }\n  path.reduce((acc, cur, idx) => {\n    if (idx + 1 === path.length) {\n      acc[cur] = value;\n    } else {\n      acc[cur] = acc[cur] || {};\n    }\n    return acc[cur];\n  }, target);\n}\n\nexport function createSimpleProduce(disableImmer = false) {\n  return function simpleProduce(path, state, fn) {\n    if (disableImmer) {\n      const current = get(path, state);\n      const next = fn(current);\n      if (current !== next) {\n        return newify(path, state, next);\n      }\n      return state;\n    }\n    if (!easyPeasyImmer) {\n      easyPeasyImmer = new Immer({\n        // We need to ensure that we disable proxies if they aren't available\n        // on the environment. Users need to ensure that they use the enableES5\n        // feature of immer.\n        useProxies:\n          typeof Proxy !== 'undefined' &&\n          typeof Proxy.revocable !== 'undefined' &&\n          typeof Reflect !== 'undefined',\n        // Autofreezing breaks easy-peasy, we need a mixed version of immutability\n        // and mutability in order to apply updates to our computed properties\n        autoFreeze: false,\n      });\n    }\n    if (path.length === 0) {\n      const draft = easyPeasyImmer.createDraft(state);\n      const result = fn(draft);\n      if (result) {\n        return isDraft(result) ? easyPeasyImmer.finishDraft(result) : result;\n      }\n      return easyPeasyImmer.finishDraft(draft);\n    }\n    const parentPath = path.slice(0, path.length - 1);\n    const draft = easyPeasyImmer.createDraft(state);\n    const parent = get(parentPath, state);\n    const current = get(path, draft);\n    const result = fn(current);\n\n    if (result) {\n      parent[path[path.length - 1]] = result;\n    }\n    return easyPeasyImmer.finishDraft(draft);\n  };\n}\n\nconst pReduce = (iterable, reducer, initialValue) =>\n  new Promise((resolve, reject) => {\n    const iterator = iterable[Symbol.iterator]();\n    let index = 0;\n\n    const next = (total) => {\n      const element = iterator.next();\n\n      if (element.done) {\n        resolve(total);\n        return;\n      }\n\n      Promise.all([total, element.value])\n        .then((value) =>\n          // eslint-disable-next-line no-plusplus\n          next(reducer(value[0], value[1], index++)),\n        )\n        .catch((err) => reject(err));\n    };\n\n    next(initialValue);\n  });\n\nexport const pSeries = (tasks) => {\n  const results = [];\n  return pReduce(tasks, (_, task) =>\n    task().then((value) => {\n      results.push(value);\n    }),\n  ).then(() => results);\n};\n\nexport function areInputsEqual(newInputs, lastInputs) {\n  if (newInputs.length !== lastInputs.length) {\n    return false;\n  }\n  for (let i = 0; i < newInputs.length; i += 1) {\n    if (newInputs[i] !== lastInputs[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// export function memoizeOne(resultFn) {\n//   let lastArgs = [];\n//   let lastResult;\n//   let calledOnce = false;\n\n//   return function memoized(...args) {\n//     if (calledOnce && areInputsEqual(args, lastArgs)) {\n//       return lastResult;\n//     }\n//     lastResult = resultFn(...args);\n//     calledOnce = true;\n//     lastArgs = args;\n//     return lastResult;\n//   };\n// }\n\nexport function useMemoOne(\n  // getResult changes on every call,\n  getResult,\n  // the inputs array changes on every call\n  inputs,\n) {\n  // using useState to generate initial value as it is lazy\n  const initial = React.useState(() => ({\n    inputs,\n    result: getResult(),\n  }))[0];\n\n  const committed = React.useRef(initial);\n\n  // persist any uncommitted changes after they have been committed\n\n  const isInputMatch = Boolean(\n    inputs &&\n      committed.current.inputs &&\n      areInputsEqual(inputs, committed.current.inputs),\n  );\n\n  // create a new cache if required\n  const cache = isInputMatch\n    ? committed.current\n    : {\n        inputs,\n        result: getResult(),\n      };\n\n  // commit the cache\n  React.useEffect(() => {\n    committed.current = cache;\n  }, [cache]);\n\n  return cache.result;\n}\n","import { isDraft, original } from 'immer';\nimport { createSimpleProduce, get } from './lib';\n\nexport default function createReducer(disableImmer, _aRD, _cR, _cP) {\n  const simpleProduce = createSimpleProduce(disableImmer);\n\n  const runActionReducerAtPath = (state, action, actionReducer, path) =>\n    simpleProduce(path, state, (draft) => actionReducer(draft, action.payload));\n\n  const reducerForActions = (state, action) => {\n    const actionReducer = _aRD[action.type];\n    if (actionReducer) {\n      return runActionReducerAtPath(\n        state,\n        action,\n        actionReducer,\n        actionReducer.def.meta.parent,\n      );\n    }\n    return state;\n  };\n\n  const reducerForCustomReducers = (state, action) =>\n    _cR.reduce(\n      (acc, { parentPath, key, reducer }) =>\n        simpleProduce(parentPath, acc, (draft) => {\n          draft[key] = reducer(\n            isDraft(draft[key]) ? original(draft[key]) : draft[key],\n            action,\n          );\n          return draft;\n        }),\n      state,\n    );\n\n  const rootReducer = (state, action) => {\n    const stateAfterActions = reducerForActions(state, action);\n    const next =\n      _cR.length > 0\n        ? reducerForCustomReducers(stateAfterActions, action)\n        : stateAfterActions;\n    if (state !== next) {\n      _cP.forEach(({ parentPath, bindComputedProperty }) => {\n        const parentState = get(parentPath, next);\n        if (parentState != null) bindComputedProperty(parentState, next);\n      });\n    }\n    return next;\n  };\n\n  return rootReducer;\n}\n","import { clone, get, isPlainObject, isPromise, set, pSeries } from './lib';\n\nconst noopStorage = {\n  getItem: () => undefined,\n  setItem: () => undefined,\n  removeItem: () => undefined,\n};\n\nconst getBrowerStorage = (storageName) => {\n  let storageCache;\n  return () => {\n    if (!storageCache) {\n      try {\n        if (\n          typeof window !== 'undefined' &&\n          typeof window[storageName] !== 'undefined'\n        ) {\n          storageCache = window[storageName];\n        }\n      } catch (_) {\n        // swallow the failure\n      }\n      if (!storageCache) {\n        storageCache = noopStorage;\n      }\n    }\n\n    return storageCache;\n  };\n};\n\nconst localStorage = getBrowerStorage('localStorage');\nconst sessionStorage = getBrowerStorage('sessionStorage');\n\nfunction createStorageWrapper(storage, transformers = []) {\n  if (storage == null) {\n    storage = sessionStorage();\n  }\n\n  if (typeof storage === 'string') {\n    if (storage === 'localStorage') {\n      storage = localStorage();\n    } else if (storage === 'sessionStorage') {\n      storage = sessionStorage();\n    } else {\n      if (process.env.NODE_ENV === 'development') {\n        console.warn(`Invalid storage provider`);\n      }\n      storage = noopStorage;\n    }\n  }\n\n  const outTransformers = [...transformers].reverse();\n\n  const serialize = (data) => {\n    if (transformers.length > 0 && data != null && typeof data === 'object') {\n      Object.keys(data).forEach((key) => {\n        data[key] = transformers.reduce(\n          (acc, cur) => cur.in(acc, key),\n          data[key],\n        );\n      });\n    }\n\n    return storage === localStorage() || storage === sessionStorage()\n      ? JSON.stringify({ data })\n      : data;\n  };\n\n  const deserialize = (data) => {\n    const result =\n      storage === localStorage() || storage === sessionStorage()\n        ? JSON.parse(data).data\n        : data;\n    if (\n      outTransformers.length > 0 &&\n      result != null &&\n      typeof result === 'object'\n    ) {\n      Object.keys(result).forEach((key) => {\n        result[key] = outTransformers.reduce(\n          (acc, cur) => cur.out(acc, key),\n          result[key],\n        );\n      });\n    }\n    return result;\n  };\n\n  const isAsync = isPromise(storage.getItem('_'));\n\n  return {\n    getItem: (key) => {\n      if (isAsync) {\n        return storage\n          .getItem(key)\n          .then((wrapped) =>\n            wrapped != null ? deserialize(wrapped) : undefined,\n          );\n      }\n      const wrapped = storage.getItem(key);\n      return wrapped != null ? deserialize(wrapped) : undefined;\n    },\n    setItem: (key, data) => storage.setItem(key, serialize(data)),\n    removeItem: (key) => storage.removeItem(key),\n  };\n}\n\nexport function extractPersistConfig(path, persistdef = {}) {\n  return {\n    path,\n    config: {\n      allow: persistdef.allow || [],\n      deny: persistdef.deny || [],\n      mergeStrategy: persistdef.mergeStrategy || 'mergeDeep',\n      storage: createStorageWrapper(\n        persistdef.storage,\n        persistdef.transformers,\n      ),\n    },\n  };\n}\n\nfunction resolvePersistTargets(target, allow, deny) {\n  let targets = Object.keys(target);\n  if (allow.length > 0) {\n    targets = targets.reduce((acc, cur) => {\n      if (allow.findIndex((x) => x === cur) !== -1) {\n        return [...acc, cur];\n      }\n      return acc;\n    }, []);\n  }\n  if (deny.length > 0) {\n    targets = targets.reduce((acc, cur) => {\n      if (deny.findIndex((x) => x === cur) !== -1) {\n        return acc;\n      }\n      return [...acc, cur];\n    }, []);\n  }\n  return targets;\n}\n\nfunction createPersistenceClearer(persistKey, _r) {\n  return () => {\n    if (_r._i._persistenceConfig.length === 0) {\n      return Promise.resolve();\n    }\n    return pSeries(\n      _r._i._persistenceConfig.map(({ path, config }) => () =>\n        Promise.resolve(config.storage.removeItem(persistKey(path))),\n      ),\n    );\n  };\n}\n\nexport function createPersistor(persistKey, _r) {\n  let persistPromise = Promise.resolve();\n  let isPersisting = false;\n  let nextPersistOperation;\n\n  const timingMethod =\n    typeof window === 'undefined'\n      ? (fn) => fn()\n      : window.requestIdleCallback != null\n      ? window.requestIdleCallback\n      : window.requestAnimationFrame;\n\n  const persist = (nextState) => {\n    if (_r._i._persistenceConfig.length === 0) {\n      return;\n    }\n\n    const operation = () => {\n      isPersisting = true;\n      persistPromise = new Promise((resolve) => {\n        timingMethod(() => {\n          pSeries(\n            _r._i._persistenceConfig.map(({ path, config }) => () => {\n              const { storage, allow, deny } = config;\n              const persistRootState = clone(get(path, nextState));\n              const persistTargets = resolvePersistTargets(\n                persistRootState,\n                allow,\n                deny,\n              );\n              const stateToPersist = {};\n              persistTargets.map((key) => {\n                const targetPath = [...path, key];\n                const rawValue = get(targetPath, nextState);\n                const value = isPlainObject(rawValue)\n                  ? clone(rawValue)\n                  : rawValue;\n                stateToPersist[key] = value;\n              });\n              return Promise.resolve(\n                storage.setItem(persistKey(path), stateToPersist),\n              );\n            }),\n          ).finally(() => {\n            isPersisting = false;\n            if (nextPersistOperation) {\n              const next = nextPersistOperation;\n              nextPersistOperation = null;\n              next();\n            } else {\n              resolve();\n            }\n          });\n        });\n      });\n    };\n\n    if (isPersisting) {\n      nextPersistOperation = operation;\n    } else {\n      operation();\n    }\n  };\n\n  return {\n    persist,\n    clear: createPersistenceClearer(persistKey, _r),\n    flush: () => {\n      if (nextPersistOperation) {\n        nextPersistOperation();\n      }\n      return persistPromise;\n    },\n  };\n}\n\nexport function createPersistMiddleware(persistor, _r) {\n  return ({ getState }) => (next) => (action) => {\n    const state = next(action);\n    if (\n      action &&\n      action.type !== '@action.ePRS' &&\n      _r._i._persistenceConfig.length > 0\n    ) {\n      persistor.persist(getState());\n    }\n    return state;\n  };\n}\n\nexport function rehydrateStateFromPersistIfNeeded(\n  persistKey,\n  replaceState,\n  _r,\n  root,\n) {\n  if (_r._i._persistenceConfig.length === 0) {\n    return Promise.resolve();\n  }\n\n  const state = clone(_r._i._dS);\n\n  let rehydrating = false;\n\n  return pSeries(\n    _r._i._persistenceConfig.map((persistInstance) => () => {\n      const { path, config } = persistInstance;\n      const { mergeStrategy, storage } = config;\n\n      if (root && (path.length < 1 || path[0] !== root)) {\n        return Promise.resolve();\n      }\n\n      const hasDataModelChanged = (dataModel, rehydratingModelData) =>\n        dataModel != null &&\n        rehydratingModelData != null &&\n        (typeof dataModel !== typeof rehydratingModelData ||\n          (Array.isArray(dataModel) && !Array.isArray(rehydratingModelData)));\n\n      const applyRehydrationStrategy = (persistedState) => {\n        if (mergeStrategy === 'overwrite') {\n          set(path, state, persistedState);\n        } else if (mergeStrategy === 'mergeShallow') {\n          const targetState = get(path, state);\n          Object.keys(persistedState).forEach((key) => {\n            if (hasDataModelChanged(targetState[key], persistedState[key])) {\n              // skip as the data model type has changed since the data was persisted\n            } else {\n              targetState[key] = persistedState[key];\n            }\n          });\n        } else if (mergeStrategy === 'mergeDeep') {\n          const targetState = get(path, state);\n          const setAt = (currentTargetState, currentPersistedState) => {\n            Object.keys(currentPersistedState).forEach((key) => {\n              if (\n                hasDataModelChanged(\n                  currentTargetState[key],\n                  currentPersistedState[key],\n                )\n              ) {\n                // skip as the data model type has changed since the data was persisted\n              } else if (isPlainObject(currentPersistedState[key])) {\n                currentTargetState[key] = currentTargetState[key] || {};\n                setAt(currentTargetState[key], currentPersistedState[key]);\n              } else {\n                currentTargetState[key] = currentPersistedState[key];\n              }\n            });\n          };\n          setAt(targetState, persistedState);\n        }\n      };\n\n      const rehydate = (persistedState) => {\n        if (persistedState != null) {\n          applyRehydrationStrategy(persistedState);\n          rehydrating = true;\n        }\n      };\n\n      const getItemResult = storage.getItem(persistKey(path));\n      if (isPromise(getItemResult)) {\n        return getItemResult.then(rehydate);\n      }\n      return Promise.resolve(rehydate(getItemResult));\n    }),\n  ).then(() => {\n    if (rehydrating) {\n      replaceState(state);\n    }\n  });\n}\n","import { actionOnSymbol } from './constants';\n\nexport function createActionCreator(def, _r) {\n  function actionCreator(payload) {\n    const action = {\n      type: def.meta.type,\n      payload,\n    };\n    if (def[actionOnSymbol] && def.meta.resolvedTargets) {\n      payload.resolvedTargets = [...def.meta.resolvedTargets];\n    }\n    return _r.dispatch(action);\n  }\n\n  // We bind the types to the creator for easy reference by consumers\n  actionCreator.type = def.meta.type;\n\n  return actionCreator;\n}\n","import { thunkOnSymbol } from './constants';\nimport { get, isPromise } from './lib';\n\nexport function createThunkHandler(def, _r, injections, _aC) {\n  return (payload, fail) => {\n    const helpers = {\n      dispatch: _r.dispatch,\n      fail,\n      getState: () => get(def.meta.parent, _r.getState()),\n      getStoreActions: () => _aC,\n      getStoreState: _r.getState,\n      injections,\n      meta: {\n        key: def.meta.actionName,\n        parent: def.meta.parent,\n        path: def.meta.path,\n      },\n    };\n    if (def[thunkOnSymbol] && def.meta.resolvedTargets) {\n      payload.resolvedTargets = [...def.meta.resolvedTargets];\n    }\n    return def.fn(get(def.meta.parent, _aC), payload, helpers);\n  };\n}\n\nconst logThunkEventListenerError = (type, err) => {\n  // eslint-disable-next-line no-console\n  console.log(`Error in ${type}`);\n  // eslint-disable-next-line no-console\n  console.log(err);\n};\n\nconst handleEventDispatchErrors = (type, dispatcher) => (...args) => {\n  try {\n    const result = dispatcher(...args);\n    if (isPromise(result)) {\n      result.catch((err) => {\n        logThunkEventListenerError(type, err);\n      });\n    }\n  } catch (err) {\n    logThunkEventListenerError(type, err);\n  }\n};\n\nexport function createThunkActionsCreator(def, _r) {\n  const actionCreator = (payload) => {\n    const dispatchStart = handleEventDispatchErrors(def.meta.startType, () =>\n      _r.dispatch({\n        type: def.meta.startType,\n        payload,\n      }),\n    );\n\n    const dispatchFail = handleEventDispatchErrors(def.meta.failType, (err) =>\n      _r.dispatch({\n        type: def.meta.failType,\n        payload,\n        error: err,\n      }),\n    );\n\n    const dispatchSuccess = handleEventDispatchErrors(\n      def.meta.successType,\n      (result) =>\n        _r.dispatch({\n          type: def.meta.successType,\n          payload,\n          result,\n        }),\n    );\n\n    dispatchStart();\n\n    let failure = null;\n\n    const fail = (_failure) => {\n      failure = _failure;\n    };\n\n    const result = _r.dispatch(() => def.thunkHandler(payload, fail));\n\n    if (isPromise(result)) {\n      return result.then((resolved) => {\n        if (failure) {\n          dispatchFail(failure);\n        } else {\n          dispatchSuccess(resolved);\n        }\n        return resolved;\n      });\n    }\n\n    if (failure) {\n      dispatchFail(failure);\n    } else {\n      dispatchSuccess(result);\n    }\n\n    return result;\n  };\n\n  actionCreator.type = def.meta.type;\n  actionCreator.successType = def.meta.successType;\n  actionCreator.failType = def.meta.failType;\n  actionCreator.startType = def.meta.startType;\n\n  return actionCreator;\n}\n","import { get } from './lib';\n\nexport function createListenerMiddleware(_r) {\n  return () => (next) => (action) => {\n    const result = next(action);\n    if (\n      action &&\n      _r._i._lAM[action.type] &&\n      _r._i._lAM[action.type].length > 0\n    ) {\n      const sourceAction = _r._i._aCD[action.type];\n      _r._i._lAM[action.type].forEach((actionCreator) => {\n        actionCreator({\n          type: sourceAction ? sourceAction.def.meta.type : action.type,\n          payload: action.payload,\n          error: action.error,\n          result: action.result,\n        });\n      });\n    }\n    return result;\n  };\n}\n\nexport function bindListenerdefs(listenerdefs, _aC, _aCD, _lAM) {\n  listenerdefs.forEach((def) => {\n    const targets = def.targetResolver(get(def.meta.parent, _aC), _aC);\n\n    const targetTypes = (Array.isArray(targets) ? targets : [targets]).reduce(\n      (acc, target) => {\n        if (\n          typeof target === 'function' &&\n          target.def.meta.type &&\n          _aCD[target.def.meta.type]\n        ) {\n          if (target.def.meta.successType) {\n            acc.push(target.def.meta.successType);\n          } else {\n            acc.push(target.def.meta.type);\n          }\n        } else if (typeof target === 'string') {\n          acc.push(target);\n        }\n        return acc;\n      },\n      [],\n    );\n\n    def.meta.resolvedTargets = targetTypes;\n\n    targetTypes.forEach((targetType) => {\n      const listenerReg = _lAM[targetType] || [];\n      listenerReg.push(_aCD[def.meta.type]);\n      _lAM[targetType] = listenerReg;\n    });\n  });\n}\n","import { areInputsEqual } from './lib';\n\nexport function createComputedPropertyBinder(parentPath, key, def, _r) {\n  let runOnce = false;\n  let prevInputs = [];\n  let prevValue;\n  return function createComputedProperty(parentState, storeState) {\n    Object.defineProperty(parentState, key, {\n      configurable: true,\n      enumerable: true,\n      get: () => {\n        const inputs = def.stateResolvers.map((resolver) =>\n          resolver(parentState, storeState),\n        );\n        if (\n          runOnce &&\n          (areInputsEqual(prevInputs, inputs) ||\n            (_r._i._cS.isInReducer &&\n              new Error().stack.match(/shallowCopy/gi) !== null))\n        ) {\n          // We don't want computed properties resolved every time an action\n          // is handled by the reducer. They need to remain lazy, only being\n          // computed when used by a component or getState call.\n          return prevValue;\n        }\n        prevInputs = inputs;\n        prevValue = def.fn(...inputs);\n        runOnce = true;\n        return prevValue;\n      },\n    });\n  };\n}\n\nexport function createComputedPropertiesMiddleware(_r) {\n  return () => (next) => (action) => {\n    _r._i._cS.isInReducer = true;\n    const result = next(action);\n    _r._i._cS.isInReducer = false;\n    return result;\n  };\n}\n","import { get, isPromise } from './lib';\n\nexport function createEffectsMiddleware(_r) {\n  return (store) => (next) => (action) => {\n    if (_r._i._e.length === 0) {\n      return next(action);\n    }\n    const prevState = store.getState();\n    const result = next(action);\n    const nextState = store.getState();\n    _r._i._e.forEach((def) => {\n      const prevLocal = get(def.meta.parent, prevState);\n      const nextLocal = get(def.meta.parent, nextState);\n      if (prevLocal !== nextLocal) {\n        const prevDependencies = def.dependencyResolvers.map((resolver) =>\n          resolver(prevLocal),\n        );\n        const nextDependencies = def.dependencyResolvers.map((resolver) =>\n          resolver(nextLocal),\n        );\n        const hasChanged = prevDependencies.some(\n          (dependency, idx) => dependency !== nextDependencies[idx],\n        );\n        if (hasChanged) {\n          def.actionCreator(prevDependencies, nextDependencies, action);\n        }\n      }\n    });\n    return result;\n  };\n}\n\nconst logEffectError = (err) => {\n  // As users can't get a handle on effects we need to report the error\n  // eslint-disable-next-line no-console\n  console.log(err);\n};\n\nexport function createEffectHandler(def, _r, injections, _aC) {\n  const actions = get(def.meta.parent, _aC);\n\n  let dispose;\n\n  return (change) => {\n    const helpers = {\n      dispatch: _r.dispatch,\n      getState: () => get(def.meta.parent, _r.getState()),\n      getStoreActions: () => _aC,\n      getStoreState: _r.getState,\n      injections,\n      meta: {\n        key: def.meta.actionName,\n        parent: def.meta.parent,\n        path: def.meta.path,\n      },\n    };\n\n    if (dispose !== undefined) {\n      const disposeResult = dispose();\n      dispose = undefined;\n      if (isPromise(disposeResult)) {\n        disposeResult.catch(logEffectError);\n      }\n    }\n\n    const effectResult = def.fn(actions, change, helpers);\n\n    if (isPromise(effectResult)) {\n      return effectResult.then((resolved) => {\n        if (typeof resolved === 'function') {\n          if (process.env.NODE_ENV !== 'production') {\n            // Dispose functions are not allowed to be resolved asynchronously.\n            // Doing so would provide inconsistent behaviour around their execution.\n            // eslint-disable-next-line no-console\n            console.warn(\n              '[easy-peasy] Effect is asynchronously resolving a dispose fn.',\n            );\n          }\n        }\n      });\n    }\n\n    if (typeof effectResult === 'function') {\n      dispose = effectResult;\n    }\n\n    return undefined;\n  };\n}\n\nconst logEffectEventListenerError = (type, err) => {\n  // eslint-disable-next-line no-console\n  console.log(`Error in ${type}`);\n  // eslint-disable-next-line no-console\n  console.log(err);\n};\n\nconst handleEventDispatchErrors = (type, dispatcher) => (...args) => {\n  try {\n    const result = dispatcher(...args);\n    if (isPromise(result)) {\n      result.catch((err) => {\n        logEffectEventListenerError(type, err);\n      });\n    }\n  } catch (err) {\n    logEffectEventListenerError(type, err);\n  }\n};\n\nexport function createEffectActionsCreator(def, _r, effectHandler) {\n  const actionCreator = (previousDependencies, nextDependencies, action) => {\n    const change = {\n      prev: previousDependencies,\n      current: nextDependencies,\n      action,\n    };\n\n    const dispatchStart = handleEventDispatchErrors(def.meta.startType, () =>\n      _r.dispatch({\n        type: def.meta.startType,\n        change,\n      }),\n    );\n\n    const dispatchSuccess = handleEventDispatchErrors(\n      def.meta.successType,\n      () =>\n        _r.dispatch({\n          type: def.meta.successType,\n          change,\n        }),\n    );\n\n    dispatchStart();\n\n    try {\n      const result = _r.dispatch(() => effectHandler(change));\n\n      if (isPromise(result)) {\n        return result.then((resolved) => {\n          dispatchSuccess(resolved);\n          return resolved;\n        }, logEffectError);\n      }\n\n      dispatchSuccess(result);\n\n      return result;\n    } catch (err) {\n      logEffectError(err);\n    }\n  };\n\n  actionCreator.type = def.meta.type;\n  actionCreator.startType = def.meta.startType;\n  actionCreator.successType = def.meta.successType;\n  actionCreator.failType = def.meta.failType;\n\n  return actionCreator;\n}\n","import {\n  actionOnSymbol,\n  actionSymbol,\n  computedSymbol,\n  effectOnSymbol,\n  persistSymbol,\n  reducerSymbol,\n  thunkOnSymbol,\n  thunkSymbol,\n} from './constants';\nimport { get, isPlainObject, set } from './lib';\nimport { extractPersistConfig } from './persistence';\nimport { createActionCreator } from './actions';\nimport { createThunkHandler, createThunkActionsCreator } from './thunks';\nimport { bindListenerdefs } from './listeners';\nimport { createComputedPropertyBinder } from './computed-properties';\nimport { createEffectHandler, createEffectActionsCreator } from './effects';\n\nexport default function extractDataFromModel(\n  model,\n  initialState,\n  injections,\n  _r,\n) {\n  const _dS = initialState;\n  const _aCD = {};\n  const _aC = {};\n  const _aRD = {};\n  const actionThunks = {};\n  const _cP = [];\n  const _cR = [];\n  const _e = [];\n  const _lAC = {};\n  const _lAM = {};\n  const listenerdefs = [];\n  let _persistenceConfig = [];\n  const _cS = {\n    isInReducer: false,\n  };\n\n  const recursiveExtractFromModel = (current, parentPath) =>\n    Object.keys(current).forEach((key) => {\n      const value = current[key];\n      const path = [...parentPath, key];\n      const meta = {\n        parent: parentPath,\n        path,\n        key,\n      };\n      const handleValueAsState = () => {\n        const initialParentRef = get(parentPath, initialState);\n        if (initialParentRef && key in initialParentRef) {\n          set(path, _dS, initialParentRef[key]);\n        } else {\n          set(path, _dS, value);\n        }\n      };\n\n      if (key === persistSymbol) {\n        _persistenceConfig.push(extractPersistConfig(parentPath, value));\n        return;\n      }\n\n      if (value != null && typeof value === 'object') {\n        if (value[actionSymbol] || value[actionOnSymbol]) {\n          const def = { ...value };\n\n          // Determine the category of the action\n          const category = def[actionSymbol] ? '@action' : '@actionOn';\n\n          // Establish the meta data describing the action\n          def.meta = {\n            actionName: meta.key,\n            category,\n            type: `${category}.${meta.path.join('.')}`,\n            parent: meta.parent,\n            path: meta.path,\n          };\n\n          // Create the \"action creator\" function\n          def.actionCreator = createActionCreator(def, _r);\n\n          // Create a bidirectional relationship of the def/actionCreator\n          def.actionCreator.def = def;\n\n          // Create a bidirectional relationship of the def/reducer\n          def.fn.def = def;\n\n          // Add the action creator to lookup map\n          _aCD[def.meta.type] = def.actionCreator;\n\n          // Add the reducer to lookup map\n          _aRD[def.meta.type] = def.fn;\n\n          // We don't want to expose the internal action to consumers\n          if (meta.key !== 'ePRS') {\n            // Set the action creator in the \"actions\" object tree for\n            // either the listeners object tree, or the standard actions/thunks\n            // object tree\n            if (def[actionOnSymbol]) {\n              listenerdefs.push(def);\n              set(path, _lAC, def.actionCreator);\n            } else {\n              set(path, _aC, def.actionCreator);\n            }\n          }\n        } else if (value[thunkSymbol] || value[thunkOnSymbol]) {\n          const def = { ...value };\n\n          // Determine the category of the thunk\n          const category = def[thunkSymbol] ? '@thunk' : '@thunkOn';\n\n          // Establish the meta data describing the thunk\n          const type = `${category}.${meta.path.join('.')}`;\n          def.meta = {\n            actionName: meta.key,\n            parent: meta.parent,\n            path: meta.path,\n            type,\n            startType: `${type}(start)`,\n            successType: `${type}(success)`,\n            failType: `${type}(fail)`,\n          };\n\n          // Create the function that will handle, i.e. be executed, when\n          // the thunk action is created/dispatched\n          def.thunkHandler = createThunkHandler(def, _r, injections, _aC);\n\n          // Register the thunk handler\n          set(path, actionThunks, def.thunkHandler);\n\n          // Create the \"action creator\" function\n          def.actionCreator = createThunkActionsCreator(def, _r);\n\n          // Create a bidirectional relationship of the def/actionCreator\n          def.actionCreator.def = def;\n\n          // Register the action creator within the lookup map\n          _aCD[def.meta.type] = def.actionCreator;\n\n          // Set the action creator in the \"actions\" object tree for\n          // either the listeners object tree, or the standard actions/thunks\n          // object tree\n          if (def[thunkOnSymbol]) {\n            listenerdefs.push(def);\n            set(path, _lAC, def.actionCreator);\n          } else {\n            set(path, _aC, def.actionCreator);\n          }\n        } else if (value[computedSymbol]) {\n          const parent = get(parentPath, _dS);\n          const bindComputedProperty = createComputedPropertyBinder(\n            parentPath,\n            key,\n            value,\n            _r,\n          );\n          bindComputedProperty(parent, _dS);\n          _cP.push({ key, parentPath, bindComputedProperty });\n        } else if (value[reducerSymbol]) {\n          _cR.push({ key, parentPath, reducer: value.fn });\n        } else if (value[effectOnSymbol]) {\n          const def = { ...value };\n\n          // Establish the meta data describing the effect\n          const type = `@effectOn.${meta.path.join('.')}`;\n          def.meta = {\n            type,\n            actionName: meta.key,\n            parent: meta.parent,\n            path: meta.path,\n            startType: `${type}(start)`,\n            successType: `${type}(success)`,\n            failType: `${type}(fail)`,\n          };\n\n          const effectHandler = createEffectHandler(def, _r, injections, _aC);\n\n          const actionCreator = createEffectActionsCreator(\n            def,\n            _r,\n            effectHandler,\n          );\n\n          def.actionCreator = actionCreator;\n\n          _e.push(def);\n        } else if (isPlainObject(value)) {\n          const existing = get(path, _dS);\n          if (existing == null) {\n            set(path, _dS, {});\n          }\n          recursiveExtractFromModel(value, path);\n        } else {\n          handleValueAsState();\n        }\n      } else {\n        handleValueAsState();\n      }\n    });\n\n  _persistenceConfig = _persistenceConfig.sort((a, b) => {\n    const aPath = a.path.join('.');\n    const bPath = b.path.join('.');\n    if (aPath < bPath) {\n      return -1;\n    }\n    if (aPath > bPath) {\n      return 1;\n    }\n    return 0;\n  });\n\n  recursiveExtractFromModel(model, []);\n\n  bindListenerdefs(listenerdefs, _aC, _aCD, _lAM);\n\n  return {\n    _aCD,\n    _aC,\n    _aRD,\n    _cP,\n    _cR,\n    _cS,\n    _dS,\n    _e,\n    _lAC,\n    _lAM,\n    _persistenceConfig,\n  };\n}\n","import {\n  applyMiddleware,\n  compose as reduxCompose,\n  createStore as reduxCreateStore,\n} from 'redux';\nimport reduxThunk from 'redux-thunk';\nimport * as helpers from './helpers';\nimport createReducer from './create-reducer';\nimport extractDataFromModel from './extract-data-from-model';\nimport {\n  createPersistor,\n  createPersistMiddleware,\n  rehydrateStateFromPersistIfNeeded,\n} from './persistence';\nimport { createComputedPropertiesMiddleware } from './computed-properties';\nimport { createListenerMiddleware } from './listeners';\nimport { clone } from './lib';\nimport { createEffectsMiddleware } from './effects';\n\nexport function createStore(model, options = {}) {\n  const modelClone = clone(model);\n  const {\n    compose,\n    devTools = process.env.NODE_ENV !== 'production',\n    disableImmer = false,\n    enhancers = [],\n    initialState = {},\n    injections = {},\n    middleware = [],\n    mockActions = false,\n    name: storeName = `EasyPeasyStore`,\n    version = 0,\n    reducerEnhancer = (rootReducer) => rootReducer,\n  } = options;\n\n  const bindReplaceState = (modelDef) => ({\n    ...modelDef,\n    ePRS: helpers.action((_, payload) => payload),\n  });\n\n  const _r = {};\n\n  let modeldef = bindReplaceState(modelClone);\n  let mockedActions = [];\n\n  const persistKey = (targetPath) =>\n    `[${storeName}][${version}]${\n      targetPath.length > 0 ? `[${targetPath.join('.')}]` : ''\n    }`;\n  const persistor = createPersistor(persistKey, _r);\n  const persistMiddleware = createPersistMiddleware(persistor, _r);\n\n  const replaceState = (nextState) => _r._i._aCD['@action.ePRS'](nextState);\n\n  const bindStoreInternals = (state = {}) => {\n    const data = extractDataFromModel(modeldef, state, injections, _r);\n    _r._i = {\n      ...data,\n      reducer: reducerEnhancer(\n        createReducer(disableImmer, data._aRD, data._cR, data._cP),\n      ),\n    };\n  };\n\n  const mockActionsMiddleware = () => () => (action) => {\n    if (action != null) {\n      mockedActions.push(action);\n    }\n    return undefined;\n  };\n\n  const composeEnhancers =\n    compose ||\n    (devTools &&\n    typeof window !== 'undefined' &&\n    window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\n      ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({\n          name: storeName,\n        })\n      : reduxCompose);\n\n  bindStoreInternals(initialState);\n\n  const easyPeasyMiddleware = [\n    createComputedPropertiesMiddleware(_r),\n    ...middleware,\n    reduxThunk,\n    createListenerMiddleware(_r),\n    createEffectsMiddleware(_r),\n    persistMiddleware,\n  ];\n\n  if (mockActions) {\n    easyPeasyMiddleware.push(mockActionsMiddleware);\n  }\n\n  const store = reduxCreateStore(\n    _r._i.reducer,\n    _r._i._dS,\n    composeEnhancers(applyMiddleware(...easyPeasyMiddleware), ...enhancers),\n  );\n\n  store.subscribe(() => {\n    _r._i._cS.isInReducer = false;\n  });\n\n  _r.dispatch = store.dispatch;\n  _r.getState = store.getState;\n\n  const bindActionCreators = () => {\n    Object.keys(store.dispatch).forEach((actionsKey) => {\n      delete store.dispatch[actionsKey];\n    });\n    Object.keys(_r._i._aC).forEach((key) => {\n      store.dispatch[key] = _r._i._aC[key];\n    });\n  };\n\n  bindActionCreators();\n\n  const rebindStore = (removeKey) => {\n    const currentState = store.getState();\n    if (removeKey) {\n      delete currentState[removeKey];\n    }\n    bindStoreInternals(currentState);\n    store.replaceReducer(_r._i.reducer);\n    replaceState(_r._i._dS);\n    bindActionCreators();\n  };\n\n  const resolveRehydration = rehydrateStateFromPersistIfNeeded(\n    persistKey,\n    replaceState,\n    _r,\n  );\n\n  return Object.assign(store, {\n    addModel: (key, modelForKey) => {\n      if (modeldef[key] && process.env.NODE_ENV !== 'production') {\n        store.removeModel(key);\n      }\n      modeldef[key] = modelForKey;\n      rebindStore();\n      // There may have been persisted state for a dynamic model. We should try\n      // and rehydrate the specifc node\n      const addModelRehydration = rehydrateStateFromPersistIfNeeded(\n        persistKey,\n        replaceState,\n        _r,\n        key,\n      );\n      return {\n        resolveRehydration: () => addModelRehydration,\n      };\n    },\n    clearMockedActions: () => {\n      mockedActions = [];\n    },\n    getActions: () => _r._i._aC,\n    getListeners: () => _r._i._lAC,\n    getMockedActions: () => [...mockedActions],\n    persist: {\n      clear: persistor.clear,\n      flush: persistor.flush,\n      resolveRehydration: () => resolveRehydration,\n    },\n    reconfigure: (newModel) => {\n      modeldef = bindReplaceState(newModel);\n      rebindStore();\n    },\n    removeModel: (key) => {\n      if (!modeldef[key]) {\n        return;\n      }\n      delete modeldef[key];\n      rebindStore(key);\n    },\n  });\n}\n","/* eslint-disable react/prop-types */\n\nimport React, { createContext, useContext } from 'react';\nimport {\n  createStoreActionsHook,\n  createStoreDispatchHook,\n  createStoreStateHook,\n  createStoreRehydratedHook,\n} from './hooks';\nimport { createStore } from './create-store';\nimport { useMemoOne } from './lib';\n\nexport function createContextStore(model, config = {}) {\n  // We create a mutable injections reference to allow updating it\n  const { injections: mutableInjections = {} } = config;\n\n  const StoreContext = createContext();\n\n  function Provider({ children, runtimeModel, injections }) {\n    // If the user provided injections we need to ensure our mutable ref\n    // is up to date. We could consider doing a shallow compare here?\n    if (injections != null) {\n      const nextInjections =\n        typeof injections === 'function'\n          ? injections(mutableInjections)\n          : injections;\n      const nextKeys = Object.keys(nextInjections);\n      const removeKeys = Object.keys(mutableInjections).filter(\n        (k) => !nextKeys.includes(k),\n      );\n      removeKeys.forEach((k) => {\n        delete mutableInjections[k];\n      });\n      Object.assign(mutableInjections, nextInjections);\n    }\n\n    const store = useMemoOne(\n      () =>\n        createStore(typeof model === 'function' ? model(runtimeModel) : model, {\n          ...config,\n          originalInjections: mutableInjections,\n        }),\n      [],\n    );\n    return (\n      <StoreContext.Provider value={store}>{children}</StoreContext.Provider>\n    );\n  }\n\n  function useStore() {\n    return useContext(StoreContext);\n  }\n\n  return {\n    Provider,\n    useStore,\n    useStoreState: createStoreStateHook(StoreContext),\n    useStoreActions: createStoreActionsHook(StoreContext),\n    useStoreDispatch: createStoreDispatchHook(StoreContext),\n    useStoreRehydrated: createStoreRehydratedHook(StoreContext),\n  };\n}\n","/**\n * This file has been copied from redux-persist.\n * The intention being to support as much of the redux-persist API as possible.\n */\n\nexport function createTransform(inbound, outbound, config = {}) {\n  const whitelist = config.whitelist || null;\n  const blacklist = config.blacklist || null;\n\n  function whitelistBlacklistCheck(key) {\n    if (whitelist && whitelist.indexOf(key) === -1) return true;\n    if (blacklist && blacklist.indexOf(key) !== -1) return true;\n    return false;\n  }\n\n  return {\n    in: (data, key, fullState) =>\n      !whitelistBlacklistCheck(key) && inbound\n        ? inbound(data, key, fullState)\n        : data,\n    out: (data, key, fullState) =>\n      !whitelistBlacklistCheck(key) && outbound\n        ? outbound(data, key, fullState)\n        : data,\n  };\n}\n","/* eslint-disable react/prop-types */\n\nimport React from 'react';\nimport StoreContext from './context';\n\nexport function StoreProvider({ children, store }) {\n  return (\n    <StoreContext.Provider value={store}>{children}</StoreContext.Provider>\n  );\n}\n","import { useEffect, useRef, useState } from 'react';\nimport { useMemoOne } from './lib';\nimport { createStore } from './create-store';\n\nexport function useLocalStore(modelCreator, dependencies = [], configCreator) {\n  const storeRef = useRef();\n\n  const configRef = useRef();\n\n  const store = useMemoOne(() => {\n    const previousState =\n      storeRef.current != null ? storeRef.current.getState() : undefined;\n    const config =\n      configCreator != null\n        ? configCreator(previousState, configRef.current)\n        : undefined;\n    const _store = createStore(modelCreator(previousState), config);\n    configRef.current = config;\n    storeRef.current = _store;\n    return _store;\n  }, dependencies);\n\n  const [currentState, setCurrentState] = useState(() => store.getState());\n\n  useEffect(\n    () => {\n      setCurrentState(store.getState());\n      store.subscribe(() => {\n        const nextState = store.getState();\n        if (currentState !== nextState) {\n          setCurrentState(nextState);\n        }\n      });\n    },\n    [store],\n  );\n\n  return [currentState, store.getActions(), store];\n}\n"]},"metadata":{},"sourceType":"module"}